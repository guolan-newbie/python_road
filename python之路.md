---
typora-root-url: assets
---

python之路
=================

  * [typora\-root\-url: assets](#typora-root-url-assets)
* [python笔记](#python%E7%AC%94%E8%AE%B0)
  * [前言](#%E5%89%8D%E8%A8%80)
    * [一、 认识 Python](#%E4%B8%80-%E8%AE%A4%E8%AF%86-python)
      * [1\. Python 的起源](#1-python-%E7%9A%84%E8%B5%B7%E6%BA%90)
        * [1\.1 解释器（科普）](#11-%E8%A7%A3%E9%87%8A%E5%99%A8%E7%A7%91%E6%99%AE)
          * [1\.1\.1编译型语言和解释型语言对比](#111%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94)
        * [1\.2 Python 的设计目标](#12-python-%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87)
        * [1\.3 Python 的设计哲学](#13-python-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6)
      * [2\. 为什么选择 Python？](#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-python)
      * [3\. Python 特点](#3-python-%E7%89%B9%E7%82%B9)
        * [3\.1面向对象的思维方式](#31%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F)
      * [4\. Python 的优缺点](#4-python-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9)
        * [4\.1 优点](#41-%E4%BC%98%E7%82%B9)
        * [4\.2 缺点](#42-%E7%BC%BA%E7%82%B9)
    * [二、python下载与安装](#%E4%BA%8Cpython%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85)
      * [1\.下载](#1%E4%B8%8B%E8%BD%BD)
      * [2\.安装](#2%E5%AE%89%E8%A3%85)
    * [三、pycharm下载与安装](#%E4%B8%89pycharm%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85)
      * [1、下载](#1%E4%B8%8B%E8%BD%BD-1)
      * [2 、安装](#2-%E5%AE%89%E8%A3%85)
    * [四、pycharm破解激活](#%E5%9B%9Bpycharm%E7%A0%B4%E8%A7%A3%E6%BF%80%E6%B4%BB)
      * [1、 下载新版破解补丁](#1-%E4%B8%8B%E8%BD%BD%E6%96%B0%E7%89%88%E7%A0%B4%E8%A7%A3%E8%A1%A5%E4%B8%81)
      * [2、打开pycharm 进入项目界面](#2%E6%89%93%E5%BC%80pycharm-%E8%BF%9B%E5%85%A5%E9%A1%B9%E7%9B%AE%E7%95%8C%E9%9D%A2)
      * [3、修改配置文件](#3%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
      * [4、激活](#4%E6%BF%80%E6%B4%BB)
      * [5、查看有效期](#5%E6%9F%A5%E7%9C%8B%E6%9C%89%E6%95%88%E6%9C%9F)
  * [二、python基础](#%E4%BA%8Cpython%E5%9F%BA%E7%A1%80)
    * [一、注释和算数运算符、程序的执行原理](#%E4%B8%80%E6%B3%A8%E9%87%8A%E5%92%8C%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86)
      * [1\. 注释](#1-%E6%B3%A8%E9%87%8A)
        * [1\.1 注释的作用](#11-%E6%B3%A8%E9%87%8A%E7%9A%84%E4%BD%9C%E7%94%A8)
        * [1\. 2 单行注释(行注释)](#1-2-%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A%E8%A1%8C%E6%B3%A8%E9%87%8A)
        * [1\.3 在代码后面增加的单行注释](#13-%E5%9C%A8%E4%BB%A3%E7%A0%81%E5%90%8E%E9%9D%A2%E5%A2%9E%E5%8A%A0%E7%9A%84%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A)
        * [1\.4 多行注释（块注释）](#14-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A%E5%9D%97%E6%B3%A8%E9%87%8A)
        * [1\.5 什么时候需要使用注释？](#15-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%A8%E9%87%8A)
        * [1\.6  关于代码的规范](#16--%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E7%9A%84%E8%A7%84%E8%8C%83)
      * [2\.算数运算符](#2%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6)
        * [2\.1  算数运算符](#21--%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6)
        * [2\.2 算数运算符的优先级](#22-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7)
      * [3\. 程序执行原理](#3-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86)
        * [1\. 计算机中的三大件](#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E4%BB%B6)
        * [2\. 程序执行的原理](#2-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8E%9F%E7%90%86)
          * [2\.1 Python 程序执行原理](#21-python-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86)
          * [2\.2 Python 的解释器有多大？](#22-python-%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8%E6%9C%89%E5%A4%9A%E5%A4%A7)
    * [二、变量以及分支语句](#%E4%BA%8C%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5)
      * [1\.变量](#1%E5%8F%98%E9%87%8F)
        * [1\.1 变量定义](#11-%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89)
        * [1\.1\.1 变量演练 —— 使用PyCharm](#111-%E5%8F%98%E9%87%8F%E6%BC%94%E7%BB%83--%E4%BD%BF%E7%94%A8pycharm)
        * [1\.2 变量的类型](#12-%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B)
          * [1\.2\.1 变量的类型](#121-%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B)
          * [1\.2\.1 变量类型的练习 —— 个人信息](#121-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%83%E4%B9%A0--%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF)
        * [1\.3 不同类型变量之间的计算](#13-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%A1%E7%AE%97)
          * [1\.3\.1<strong>数字型变量</strong> 之间可以直接计算](#131%E6%95%B0%E5%AD%97%E5%9E%8B%E5%8F%98%E9%87%8F-%E4%B9%8B%E9%97%B4%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%AE%A1%E7%AE%97)
          * [1\.3\.2  <strong>字符串变量</strong> 之间使用 \+ 拼接字符串](#132--%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F-%E4%B9%8B%E9%97%B4%E4%BD%BF%E7%94%A8--%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2)
          * [1\.3\.3  <strong>字符串变量</strong> 可以和 <strong>整数</strong> 使用 \* 重复拼接相同的字符串](#133--%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F-%E5%8F%AF%E4%BB%A5%E5%92%8C-%E6%95%B4%E6%95%B0-%E4%BD%BF%E7%94%A8--%E9%87%8D%E5%A4%8D%E6%8B%BC%E6%8E%A5%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2)
          * [1\.3\.4 <strong>数字型变量</strong> 和 <strong>字符串</strong> 之间 <strong>不能进行其他计算</strong>](#134-%E6%95%B0%E5%AD%97%E5%9E%8B%E5%8F%98%E9%87%8F-%E5%92%8C-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E4%B9%8B%E9%97%B4-%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E5%85%B6%E4%BB%96%E8%AE%A1%E7%AE%97)
        * [1\.4 变量的输入](#14-%E5%8F%98%E9%87%8F%E7%9A%84%E8%BE%93%E5%85%A5)
          * [1\.4\.1  关于函数](#141--%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0)
          * [1\.4\.2input 函数实现键盘输入](#142input-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5)
          * [1\.4\.3 类型转换函数](#143-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0)
          * [1\.4\.4 变量输入练习](#144-%E5%8F%98%E9%87%8F%E8%BE%93%E5%85%A5%E7%BB%83%E4%B9%A0)
        * [1\.5 变量的格式化输出](#15-%E5%8F%98%E9%87%8F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA)
          * [1\.5\.1 格式化输出练习](#151-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%BB%83%E4%B9%A0)
      * [2、分支语句](#2%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5)
        * [2\.1  判断语句————if](#21--%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5if)
          * [2\.1\.1  判断的定义](#211--%E5%88%A4%E6%96%AD%E7%9A%84%E5%AE%9A%E4%B9%89)
          * [2\.1\.2 if 判断语句基本语法](#212-if-%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95)
          * [2\.1\.3 else 处理条件不满足的情况](#213-else-%E5%A4%84%E7%90%86%E6%9D%A1%E4%BB%B6%E4%B8%8D%E6%BB%A1%E8%B6%B3%E7%9A%84%E6%83%85%E5%86%B5)
          * [2\.1\.4  if 语句进阶之elif](#214--if-%E8%AF%AD%E5%8F%A5%E8%BF%9B%E9%98%B6%E4%B9%8Belif)
          * [2\.1\.5 if 的嵌套](#215-if-%E7%9A%84%E5%B5%8C%E5%A5%97)
        * [2\.2  逻辑运算](#22--%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97)
          * [2\.2\.1  and](#221--and)
          * [2\.2\.2 or](#222-or)
          * [2\.2\.3 not](#223-not)
        * [2\.3 运算符](#23-%E8%BF%90%E7%AE%97%E7%AC%A6)
          * [2\.3\.1  算数运算符](#231--%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6)
          * [2\.3\.2  比较（关系）运算符](#232--%E6%AF%94%E8%BE%83%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6)
          * [2\.3\.3  逻辑运算符](#233--%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6)
          * [2\.3\.4  赋值运算符](#234--%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6)
          * [2\.3\.5  运算符的优先级](#235--%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7)
        * [2\.4  循环](#24--%E5%BE%AA%E7%8E%AF)
          * [2\.4\.1 while 循环基本使用](#241-while-%E5%BE%AA%E7%8E%AF%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8)
          * [2\.4\.2  break 和 continue](#242--break-%E5%92%8C-continue)
          * [2\.4\.3 while 循环嵌套](#243-while-%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97)
      * [3、 高级变量类型](#3-%E9%AB%98%E7%BA%A7%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B)
        * [3\.1 列表](#31-%E5%88%97%E8%A1%A8)
          * [3\.1\.1 列表的定义](#311-%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89)
          * [3\.1\.2 列表常用操作](#312-%E5%88%97%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C)
          * [3\.1\.3 循环遍历列表](#313-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8)
        * [3\.2 元组](#32-%E5%85%83%E7%BB%84)
          * [3\.2\.1 元组的定义](#321-%E5%85%83%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89)
          * [3\.2\.2 元组常用操作](#322-%E5%85%83%E7%BB%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C)
          * [3\.2\.3 循环遍历](#323-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86)
          * [3\.2\.4 元组和列表之间的转换](#324-%E5%85%83%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2)
        * [3\.3 字典](#33-%E5%AD%97%E5%85%B8)
          * [3\.3\.1 字典的定义](#331-%E5%AD%97%E5%85%B8%E7%9A%84%E5%AE%9A%E4%B9%89)
          * [3\.3\.2 字典常用操作](#332-%E5%AD%97%E5%85%B8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C)
          * [3\.3\.3 循环遍历](#333-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86)
        * [3\.4 字符串](#34-%E5%AD%97%E7%AC%A6%E4%B8%B2)
          * [3\.4\.1 字符串的定义](#341-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89)
          * [3\.4\.2 字符串的常用操作](#342-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C)
          * [3\.4\.3 字符串的切片](#343-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%87%E7%89%87)
        * [3\.5  公共方法](#35--%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95)
          * [3\.5\.1 Python 内置函数](#351-python-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0)
          * [3\.5\.2  运算符](#352--%E8%BF%90%E7%AE%97%E7%AC%A6)
          * [3\.5\.3 完整的 for 循环语法](#353-%E5%AE%8C%E6%95%B4%E7%9A%84-for-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E6%B3%95)
      * [4、函数与模块](#4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%A8%A1%E5%9D%97)
        * [4\.1 函数](#41-%E5%87%BD%E6%95%B0)
          * [4\.1\.1 函数的定义](#411-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89)
          * [4\.1\.2 函数调用](#412-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8)
          * [4\.1\.3 第一个函数演练](#413-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%BC%94%E7%BB%83)
          * [4\.1\.4 PyCharm 的调试工具](#414-pycharm-%E7%9A%84%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7)
          * [4\.1\.5 函数的文档注释](#415-%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A)
        * [4\.2  函数的参数](#42--%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0)
          * [4\.2\.1  函数参数的使用](#421--%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8)
          * [4\.2\.2  参数的作用](#422--%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8)
          * [4\.2\.3 形参和实参](#423-%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82)
        * [4\.3  函数的返回值](#43--%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC)
        * [4\.4 函数的嵌套调用](#44-%E5%87%BD%E6%95%B0%E7%9A%84%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8)
        * [4\.5  模块](#45--%E6%A8%A1%E5%9D%97)
          * [4\.5\.1 模块名也是一个标识符](#451-%E6%A8%A1%E5%9D%97%E5%90%8D%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%87%E8%AF%86%E7%AC%A6)
          * [4\.5\.2  Pyc 文件](#452--pyc-%E6%96%87%E4%BB%B6)
      * [5\. 变量与函数进阶](#5-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6)
        * [5\.1变量进阶](#51%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6)
          * [5\.1\.1 变量的引用](#511-%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8)
          * [5\.1\.2 函数的参数和返回值的传递](#512-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BC%A0%E9%80%92)
          * [5\.1\.3  可变和不可变类型](#513--%E5%8F%AF%E5%8F%98%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B)
          * [5\.1\.4  哈希 (hash)](#514--%E5%93%88%E5%B8%8C-hash)
          * [5\.1\.5  局部变量和全局变量](#515--%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F)
        * [5\.2 函数进阶](#52-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6)
          * [5\.2\.1 函数参数和返回值的作用](#521-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8)
          * [5\.2\.2 函数的返回值 进阶](#522-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC-%E8%BF%9B%E9%98%B6)
          * [5\.2\.3 函数的参数 进阶](#523-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0-%E8%BF%9B%E9%98%B6)
          * [5\.2\.4  缺省参数](#524--%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0)
          * [5\.2\.5  多值参数](#525--%E5%A4%9A%E5%80%BC%E5%8F%82%E6%95%B0)
        * [5\.3  函数的递归](#53--%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92)
          * [5\.3\.1 递归函数的特点](#531-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9)
  * [面向对象](#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1)
    * [一、 面向对象(OOP)](#%E4%B8%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1oop)
      * [1\. 面向对象基本概念](#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
        * [1\.1 过程和函数](#11-%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0)
        * [1\.2 面相过程 和 面相对象 基本概念](#12-%E9%9D%A2%E7%9B%B8%E8%BF%87%E7%A8%8B-%E5%92%8C-%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
      * [2\.  类和对象](#2--%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1)
        * [2\.1  类和对象的概念](#21--%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5)
          * [2\.1\.1 类](#211-%E7%B1%BB)
          * [2\.1\.2 对象](#212-%E5%AF%B9%E8%B1%A1)
        * [2\.2 类和对象的关系](#22-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB)
        * [2\.3 类的设计](#23-%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1)
          * [2\.3\.1 类名的确定](#231-%E7%B1%BB%E5%90%8D%E7%9A%84%E7%A1%AE%E5%AE%9A)
          * [2\.3\.2 属性和方法的确定](#232-%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E7%A1%AE%E5%AE%9A)
      * [3\.  面相对象基础语法](#3--%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95)
        * [3\.1 dir 内置函数](#31-dir-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0)
        * [3\.2 定义简单的类（只包含方法）](#32-%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E7%9A%84%E7%B1%BB%E5%8F%AA%E5%8C%85%E5%90%AB%E6%96%B9%E6%B3%95)
          * [3\.2\.1 创建对象](#321-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1)
          * [3\.2\.2 第一个面向对象程序](#322-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F)
        * [3\.3  引用概念的强调](#33--%E5%BC%95%E7%94%A8%E6%A6%82%E5%BF%B5%E7%9A%84%E5%BC%BA%E8%B0%83)
        * [3\.4 初始化方法](#34-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95)
          * [3\.4\.1 在初始化方法内部定义属性](#341-%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7)
          * [3\.4\.2 改造初始化方法 \-\-\-\-\-\- 初始化的同时设置初始值](#342-%E6%94%B9%E9%80%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95--------%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%80%BC)
          * [3\.4\.3 内置方法和属性](#343-%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7)
          * [3\.4\.4 \_\_del\_\_ 方法](#344-__del__-%E6%96%B9%E6%B3%95)
          * [3\.4\.5  \_\_str\_\_ 方法](#345--__str__-%E6%96%B9%E6%B3%95)
      * [4\. 面向对象三大特性\-\-\-封装、继承、多态](#4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7---%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81)
        * [4\.1 封装](#41-%E5%B0%81%E8%A3%85)
          * [4\.1\.1 面向对象封装案例 进阶](#411-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85%E6%A1%88%E4%BE%8B-%E8%BF%9B%E9%98%B6)
        * [4\.2  继承](#42--%E7%BB%A7%E6%89%BF)
          * [4\.2\.1 继承的概念、语法和特点](#421-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AF%AD%E6%B3%95%E5%92%8C%E7%89%B9%E7%82%B9)
          * [4\.2\.2 方法的重写](#422-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99)
          * [4\.2\.3 多继承](#423-%E5%A4%9A%E7%BB%A7%E6%89%BF)
          * [4\.2\.4 新式类与旧式（经典）类](#424-%E6%96%B0%E5%BC%8F%E7%B1%BB%E4%B8%8E%E6%97%A7%E5%BC%8F%E7%BB%8F%E5%85%B8%E7%B1%BB)
        * [4\.3 多态](#43-%E5%A4%9A%E6%80%81)
          * [4\.3\.1多态案例演练](#431%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%E6%BC%94%E7%BB%83)
      * [5、属性和方法](#5%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95)
        * [5\.1  私有属性和私有方法](#51--%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95)
          * [5\.1\.1 应用场景及定义方式](#511-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F)
          * [5\.1\.2 伪私有属性和私有方法](#512-%E4%BC%AA%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95)
        * [5\.2 类属性和类方法](#52-%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95)
          * [5\.2\.1 术语 \-\-\-\-\-\- 实例](#521-%E6%9C%AF%E8%AF%AD--------%E5%AE%9E%E4%BE%8B)
          * [5\.2\.2 类属性和实例属性](#522-%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7)
          * [5\.2\.3 类方法](#523-%E7%B1%BB%E6%96%B9%E6%B3%95)
          * [5\.2\.4 静态方法](#524-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95)
          * [5\.2\.5 方法综合案例](#525-%E6%96%B9%E6%B3%95%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B)
      * [6、模块和包、文件](#6%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85%E6%96%87%E4%BB%B6)
        * [6\.1 模块](#61-%E6%A8%A1%E5%9D%97)
          * [6\.1\.1 模块的两种导入方式](#611-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AF%BC%E5%85%A5%E6%96%B9%E5%BC%8F)
          * [6\.1\.2 模块的搜索顺序[扩展]](#612-%E6%A8%A1%E5%9D%97%E7%9A%84%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F%E6%89%A9%E5%B1%95)
          * [6\.1\.3 原则 \-\-\-\-\-\- 每一个文件都应该是可以被导入的](#613-%E5%8E%9F%E5%88%99--------%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%83%BD%E5%BA%94%E8%AF%A5%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AF%BC%E5%85%A5%E7%9A%84)
        * [6\.2 包（Package）](#62-%E5%8C%85package)
        * [6\.3 发布模块](#63-%E5%8F%91%E5%B8%83%E6%A8%A1%E5%9D%97)
          * [6\.3\.1 制作发布压缩包步骤](#631-%E5%88%B6%E4%BD%9C%E5%8F%91%E5%B8%83%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%AD%A5%E9%AA%A4)
          * [6\.3\.2 安装模块](#632-%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97)
          * [6\.3\.3 pip 安装第三方模块](#633-pip-%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97)
        * [6\.4 文件](#64-%E6%96%87%E4%BB%B6)
          * [6\.4\.1 文件的概念和作用](#641-%E6%96%87%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8)
          * [6\.4\.2 文件的存储方式](#642-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F)
          * [6\.4\.3 文件的基本操作](#643-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)
          * [6\.4\.4 文件指针](#644-%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88)
      * [7、单例、异常以及eval函数](#7%E5%8D%95%E4%BE%8B%E5%BC%82%E5%B8%B8%E4%BB%A5%E5%8F%8Aeval%E5%87%BD%E6%95%B0)
        * [7\.1 单例](#71-%E5%8D%95%E4%BE%8B)
          * [7\.1\.1 单例设计模式](#711-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)
          * [7\.1\.2  \_\_new\_\_ 方法](#712--__new__-%E6%96%B9%E6%B3%95)
          * [7\.1\.3  Python 中的单例](#713--python-%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B)
        * [7\.2 异常](#72-%E5%BC%82%E5%B8%B8)
          * [7\.2\.1  捕获异常](#721--%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8)
          * [7\.2\.2 错误类型捕获](#722-%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%E6%8D%95%E8%8E%B7)
          * [7\.2\.3 异常捕获完整语法](#723-%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%AE%8C%E6%95%B4%E8%AF%AD%E6%B3%95)
          * [7\.2\.3 异常的传递](#723-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BC%A0%E9%80%92)
          * [7\.2\.4  抛出 raise 异常](#724--%E6%8A%9B%E5%87%BA-raise-%E5%BC%82%E5%B8%B8)
        * [7\.3  eval 函数](#73--eval-%E5%87%BD%E6%95%B0)
          * [7\.3\.1 不要滥用 eval](#731-%E4%B8%8D%E8%A6%81%E6%BB%A5%E7%94%A8-eval)
  * [二 、面向对象实战\-飞机大战](#%E4%BA%8C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E6%88%98-%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98)
    * [1、pygame模块](#1pygame%E6%A8%A1%E5%9D%97)
      * [1\.1  使用 pygame 创建图形窗口](#11--%E4%BD%BF%E7%94%A8-pygame-%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%AA%97%E5%8F%A3)
        * [1\.1\.1  游戏的初始化和退出](#111--%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%80%80%E5%87%BA)
        * [1\.1\.2 理解游戏中的坐标系](#112-%E7%90%86%E8%A7%A3%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB)
        * [1\.1\.3  案例演练](#113--%E6%A1%88%E4%BE%8B%E6%BC%94%E7%BB%83)
      * [1\.2 创建游戏主窗口](#12-%E5%88%9B%E5%BB%BA%E6%B8%B8%E6%88%8F%E4%B8%BB%E7%AA%97%E5%8F%A3)
      * [1\.3  简单的游戏循环](#13--%E7%AE%80%E5%8D%95%E7%9A%84%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF)
    * [2、  理解 <strong>图像</strong> 并实现图像绘制](#2--%E7%90%86%E8%A7%A3-%E5%9B%BE%E5%83%8F-%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6)
      * [2\.1  代码演练](#21--%E4%BB%A3%E7%A0%81%E6%BC%94%E7%BB%83)
        * [2\.1\.1 代码演练 I —— 绘制背景图像](#211-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%BB%83-i--%E7%BB%98%E5%88%B6%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F)
        * [2\.1\.2 代码演练 II —— 绘制英雄图像](#212-%E4%BB%A3%E7%A0%81%E6%BC%94%E7%BB%83-ii--%E7%BB%98%E5%88%B6%E8%8B%B1%E9%9B%84%E5%9B%BE%E5%83%8F)
        * [2\.2  理解 update() 方法的作用](#22--%E7%90%86%E8%A7%A3-update-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8)
      * [2\.3  理解 <strong>游戏循环</strong> 和 <strong>游戏时钟</strong>](#23--%E7%90%86%E8%A7%A3-%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF-%E5%92%8C-%E6%B8%B8%E6%88%8F%E6%97%B6%E9%92%9F)
        * [2\.3\.1 游戏中的动画实现原理](#231-%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86)
        * [2\.3\.2 <strong>游戏循环</strong>](#232-%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF)
    * [3、  游戏时钟](#3--%E6%B8%B8%E6%88%8F%E6%97%B6%E9%92%9F)
      * [3\.1 英雄的简单动画实现](#31-%E8%8B%B1%E9%9B%84%E7%9A%84%E7%AE%80%E5%8D%95%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0)
      * [3\.2 在游戏循环中 监听 事件](#32-%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF%E4%B8%AD-%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6)
        * [3\.2\.1  事件 event](#321--%E4%BA%8B%E4%BB%B6-event)
        * [3\.2\.2  监听](#322--%E7%9B%91%E5%90%AC)
        * [3\.2\.3  代码实现](#323--%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
    * [4、 理解 <strong>精灵</strong> 和 <strong>精灵组</strong>](#4-%E7%90%86%E8%A7%A3-%E7%B2%BE%E7%81%B5-%E5%92%8C-%E7%B2%BE%E7%81%B5%E7%BB%84)
      * [4\.1 精灵 和 精灵组](#41-%E7%B2%BE%E7%81%B5-%E5%92%8C-%E7%B2%BE%E7%81%B5%E7%BB%84)
        * [4\.1\.1 精灵](#411-%E7%B2%BE%E7%81%B5)
        * [4\.1\.2 精灵组](#412-%E7%B2%BE%E7%81%B5%E7%BB%84)
      * [4\.2 派生精灵子类](#42-%E6%B4%BE%E7%94%9F%E7%B2%BE%E7%81%B5%E5%AD%90%E7%B1%BB)
      * [4\.3 使用 游戏精灵 和 精灵组 创建敌机](#43-%E4%BD%BF%E7%94%A8-%E6%B8%B8%E6%88%8F%E7%B2%BE%E7%81%B5-%E5%92%8C-%E7%B2%BE%E7%81%B5%E7%BB%84-%E5%88%9B%E5%BB%BA%E6%95%8C%E6%9C%BA)
        * [4\.3\.1 实现步骤](#431-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4)
    * [5、  游戏框架搭建](#5--%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA)
      * [5\.1  明确主程序职责](#51--%E6%98%8E%E7%A1%AE%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%81%8C%E8%B4%A3)
      * [5\.2 实现飞机大战主游戏类](#52-%E5%AE%9E%E7%8E%B0%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%E4%B8%BB%E6%B8%B8%E6%88%8F%E7%B1%BB)
        * [5\.2\.1 明确文件职责](#521-%E6%98%8E%E7%A1%AE%E6%96%87%E4%BB%B6%E8%81%8C%E8%B4%A3)
        * [5\.2\.2  代码实现](#522--%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
        * [5\.2\.3 游戏初始化部分](#523-%E6%B8%B8%E6%88%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%83%A8%E5%88%86)
        * [5\.2\.4 游戏循环部分](#524-%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF%E9%83%A8%E5%88%86)
      * [5\.3  准备游戏精灵组](#53--%E5%87%86%E5%A4%87%E6%B8%B8%E6%88%8F%E7%B2%BE%E7%81%B5%E7%BB%84)
        * [5\.3\.1 确定精灵组](#531-%E7%A1%AE%E5%AE%9A%E7%B2%BE%E7%81%B5%E7%BB%84)
        * [5\.3\.2 代码实现](#532-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
    * [6、 游戏背景](#6-%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF)
      * [6\.1  背景交替滚动的思路确定](#61--%E8%83%8C%E6%99%AF%E4%BA%A4%E6%9B%BF%E6%BB%9A%E5%8A%A8%E7%9A%84%E6%80%9D%E8%B7%AF%E7%A1%AE%E5%AE%9A)
        * [6\.1\.1 实现思路分析](#611-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90)
        * [6\.1\.2 设计背景类](#612-%E8%AE%BE%E8%AE%A1%E8%83%8C%E6%99%AF%E7%B1%BB)
      * [6\.2  显示游戏背景](#62--%E6%98%BE%E7%A4%BA%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF)
        * [6\.2\.1 背景精灵的基本实现（继承、重写概念）](#621-%E8%83%8C%E6%99%AF%E7%B2%BE%E7%81%B5%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E9%87%8D%E5%86%99%E6%A6%82%E5%BF%B5)
        * [6\.2\.2 在 plane\_main\.py 中显示背景精灵](#622-%E5%9C%A8-plane_mainpy-%E4%B8%AD%E6%98%BE%E7%A4%BA%E8%83%8C%E6%99%AF%E7%B2%BE%E7%81%B5)
        * [6\.2\.3 利用初始化方法，简化背景精灵创建](#623-%E5%88%A9%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95%E7%AE%80%E5%8C%96%E8%83%8C%E6%99%AF%E7%B2%BE%E7%81%B5%E5%88%9B%E5%BB%BA)
    * [7、 敌机出场](#7-%E6%95%8C%E6%9C%BA%E5%87%BA%E5%9C%BA)
      * [7\.1  使用定时器添加敌机](#71--%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%95%8C%E6%9C%BA)
        * [7\.1\.1 定时器](#711-%E5%AE%9A%E6%97%B6%E5%99%A8)
        * [7\.1\.2 定义并监听创建敌机的定时器事件](#712-%E5%AE%9A%E4%B9%89%E5%B9%B6%E7%9B%91%E5%90%AC%E5%88%9B%E5%BB%BA%E6%95%8C%E6%9C%BA%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6)
      * [7\.2  设计 Enemy 类](#72--%E8%AE%BE%E8%AE%A1-enemy-%E7%B1%BB)
        * [7\.2\.1 敌机类的准备](#721-%E6%95%8C%E6%9C%BA%E7%B1%BB%E7%9A%84%E5%87%86%E5%A4%87)
        * [7\.2\.2 创建敌机](#722-%E5%88%9B%E5%BB%BA%E6%95%8C%E6%9C%BA)
        * [7\.2\.3 随机敌机位置和速度](#723-%E9%9A%8F%E6%9C%BA%E6%95%8C%E6%9C%BA%E4%BD%8D%E7%BD%AE%E5%92%8C%E9%80%9F%E5%BA%A6)
        * [7\.2\.4 移出屏幕销毁敌机](#724-%E7%A7%BB%E5%87%BA%E5%B1%8F%E5%B9%95%E9%94%80%E6%AF%81%E6%95%8C%E6%9C%BA)
    * [8、  英雄登场](#8--%E8%8B%B1%E9%9B%84%E7%99%BB%E5%9C%BA)
      * [8\.1 设计 <strong>英雄</strong> 和 <strong>子弹</strong> 类](#81-%E8%AE%BE%E8%AE%A1-%E8%8B%B1%E9%9B%84-%E5%92%8C-%E5%AD%90%E5%BC%B9-%E7%B1%BB)
      * [8\.2 创建英雄](#82-%E5%88%9B%E5%BB%BA%E8%8B%B1%E9%9B%84)
        * [8\.2\.1 准备英雄类](#821-%E5%87%86%E5%A4%87%E8%8B%B1%E9%9B%84%E7%B1%BB)
        * [8\.2\.2 绘制英雄](#822-%E7%BB%98%E5%88%B6%E8%8B%B1%E9%9B%84)
      * [8\.3 移动英雄位置](#83-%E7%A7%BB%E5%8A%A8%E8%8B%B1%E9%9B%84%E4%BD%8D%E7%BD%AE)
      * [8\.4  发射子弹](#84--%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9)
        * [8\.4\.1 添加发射子弹事件](#841-%E6%B7%BB%E5%8A%A0%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9%E4%BA%8B%E4%BB%B6)
        * [8\.4\.2 定义子弹类](#842-%E5%AE%9A%E4%B9%89%E5%AD%90%E5%BC%B9%E7%B1%BB)
        * [8\.4\.3 发射子弹](#843-%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9)
    * [9、 碰撞检测](#9-%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B)
      * [9\.1 了解碰撞检测方法](#91-%E4%BA%86%E8%A7%A3%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95)
      * [9\.2  碰撞实现](#92--%E7%A2%B0%E6%92%9E%E5%AE%9E%E7%8E%B0)


# python笔记

## 前言

### 一、 认识 Python

> 人生苦短，我用 Python —— Life is short, you need Python

#### 1. Python 的起源

> Python 的创始人为吉多·范罗苏姆（Guido van Rossum）

1. 1989 年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的**解释程序**，作为 ABC 语言的一种继承（**感觉下什么叫牛人**）
2. ABC 是由吉多参加设计的一种教学语言，就吉多本人看来，ABC 这种语言非常优美和强大，是**专门为非专业程序员设计的**。但是 ABC 语言并没有成功，究其原因，吉多认为是**非开放**造成的。吉多决心在 Python 中避免这一错误，并获取了非常好的效果
3. 之所以选中 Python（蟒蛇） 作为程序的名字，是因为他是 BBC 电视剧——蒙提·派森的飞行马戏团（Monty Python's Flying Circus）的爱好者
4. 1991 年，第一个 Python **解释器** 诞生，它是用 C 语言实现的，并能够调用 C 语言的库文件

##### 1.1 解释器（科普）

**计算机不能直接理解任何除机器语言以外的语言**，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。**将其他语言翻译成机器语言的工具，被称为编译器**

编译器翻译的方式有两种：一个是**编译**，另外一个是**解释**。两种方式之间的区别在于**翻译时间点的不同**。当编译器**以解释方式运行的时候**，也称之为**解释器**
![解释型和编译型对比](/解释型和编译型对比.png)


* **编译型语言**：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++
* **解释型语言**：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行

###### 1.1.1编译型语言和解释型语言对比

* **速度** —— 编译型语言比解释型语言执行速度快
* **跨平台性** —— 解释型语言比编译型语言跨平台性好

##### 1.2 Python 的设计目标

1999 年，吉多·范罗苏姆向 DARPA 提交了一条名为 “Computer Programming for Everybody” 的资金申请，并在后来说明了他对 Python 的目标：

* 一门**简单直观的语言**并与主要竞争者一样强大
* **开源**，以便任何人都可以为它做贡献
* 代码**像纯英语那样容易理解**
* 适用于**短期**开发的日常任务

这些想法中的基本都已经成为现实，Python 已经成为一门流行的编程语言

##### 1.3 Python 的设计哲学

1. 优雅
2. 明确
3. 简单

<!-- > 在 Python 解释器内运行 `import this` 可以获得完整的列表 -->

* Python 开发者的哲学是：**用一种方法，最好是只有一种方法来做一件事**
* 如果面临多种选择，Python 开发者一般会拒绝花俏的语法，而选择**明确没有或者很少有歧义的语法**

> 在 Python 社区，吉多被称为“仁慈的独裁者”

#### 2. 为什么选择 Python？

* 代码量少
* ……

> 同一样问题，用不同的语言解决，代码量差距还是很多的，一般情况下 `Python` 是 `Java` 的 **1/5**，所以说 **人生苦短，我用 Python**

#### 3. Python 特点

* Python 是**完全面向对象的语言**
    * **函数**、**模块**、**数字**、**字符串**都是对象，**在 Python 中一切皆对象**
    * 完全支持继承、重载、多重继承
    * 支持重载运算符，也支持泛型设计
* Python **拥有一个强大的标准库**，Python 语言的核心只包含 **数字**、**字符串**、**列表**、**字典**、**文件** 等常见类型和函数，而由 Python 标准库提供了 **系统管理**、**网络通信**、**文本处理**、**数据库接口**、**图形系统**、**XML 处理** 等额外的功能
* Python 社区提供了**大量的第三方模块**，使用方式与标准库类似。它们的功能覆盖 **科学计算**、**人工智能**、**机器学习**、**Web 开发**、**数据库接口**、**图形系统** 多个领域

##### 3.1面向对象的思维方式

* **面向对象** 是一种 **思维方式**，也是一门 **程序设计技术**
* 要解决一个问题前，首先考虑 **由谁** 来做，怎么做事情是 **谁** 的职责，最后把事情做好就行！
    * **对象** 就是 **谁**
* 要解决复杂的问题，就可以找**多个不同的对象**，**各司其职**，共同实现，最终完成需求

#### 4. Python 的优缺点

##### 4.1 优点

* 简单、易学
* 免费、开源
* **面向对象**
* 丰富的库
* 可扩展性
    * 如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 `C` 或 `C++` 编写，然后在 `Python` 程序中使用它们
* ……

##### 4.2 缺点

* 运行速度
* 国内市场较小
* 中文料匮乏

### 二、python下载与安装

  ####  1.下载
官方下载地址：https://www.python.org/getit/

（1）访问上方链接，如下图所示，选择对应的操作系统。 
![python下载](https://img-blog.csdnimg.cn/20190517163311724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJTVBMRTE5OTU=,size_16,color_FFFFFF,t_70)
（2）选择版本。注意一下系统是32位还是64位。下面说一下web-based ,executable , embeddable zipfile区别 的区别：

web-based: 透过网络安装的，就是执行安装后才透过网络下载python。

executable: 可執行文件的，既把要安装的python全部下载好在本机安装。

embeddable zipfile: zip 压缩档，就是python打包成zip压缩包。

 #### 2.安装
（1）双击下载好的.exe文件 
（2）勾选“Add Python 3.7 to PATH”,这样会添加环境变量。点击“Install Now”。
（3）打开cmd命令窗口，输入python,回车，如下所示安装成功。
![python安装成功示例](https://img-blog.csdnimg.cn/20190517163643457.png)







## 二、python基础

### 一、注释和算数运算符、程序的执行原理

#### 1. 注释

##### 1.1 注释的作用

> 使用用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性。（通俗点讲即对你写的代码进行一个解释说明，以方便别人能够看懂该代码起什么作用。）


##### 1. 2 单行注释(行注释)

* 以 `#` 开头，`#` **右边**的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用

* 示例代码如下：

```python
# 这是第一个单行注释
print("hello python")
```

> 为了保证代码的可读性，`#` 后面建议先添加一个空格，然后再编写相应的说明文字

##### 1.3 在代码后面增加的单行注释

* 在程序开发时，同样可以使用 `#` 在代码的后面（旁边）增加说明性的文字
* 但是，需要注意的是，**为了保证代码的可读性**，**注释和代码之间** 至少要有 **两个空格**

* 示例代码如下：

```python
print("hello python")  # 输出 `hello python`
```

##### 1.4 多行注释（块注释）

* 如果希望编写的 **注释信息很多，一行无法显示**，就可以使用多行注释
* 要在 Python 程序中使用多行注释，可以用 **一对 连续的 三个 引号**(单引号和双引号都可以)

* 示例代码如下：

```python
"""
这是一个多行注释

在多行注释之间，可以写很多很多的内容……
""" 
print("hello python")
```

##### 1.5 什么时候需要使用注释？

1. **注释不是越多越好**，对于一目了然的代码，不需要添加注释
2. 对于 **复杂的操作**，应该在操作开始前写上若干行注释
3. 对于 **不是一目了然的代码**，应在其行尾添加注释（为了提高可读性，注释应该至少离开代码 2 个空格）
4. 绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么

> 在一些正规的开发团队，通常会有 **代码审核** 的惯例，就是一个团队中彼此阅读对方的代码


##### 1.6  关于代码的规范

* `Python` 官方提供有一系列 PEP（Python Enhancement Proposals） 文档
* 其中第 8 篇文档专门针对 **Python 的代码格式** 给出了建议，也就是俗称的 **PEP 8**
* 文档地址：https://www.python.org/dev/peps/pep-0008/
* 谷歌有对应的中文文档：http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/

> ps：任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步


#### 2.算数运算符

**计算机**，顾名思义就是负责进行 **数学计算** 并且 **存储计算结果** 的电子设备

##### 2.1  算数运算符

* 算数运算符是 **运算符的一种**
* 是完成基本的算术运算使用的符号，用来处理四则运算

| 运算符 |  描述  | 实例                                       |
| :----: | :----: | ------------------------------------------ |
|   +    |   加   | 10 + 20 = 30                               |
|   -    |   减   | 10 - 20 = -10                              |
|   *    |   乘   | 10 * 20 = 200                              |
|   /    |   除   | 10 / 20 = 0.5                              |
|   //   | 取整除 | 返回除法的整数部分（商） 9 // 2 输出结果 4 |
|   %    | 取余数 | 返回除法的余数 9 % 2 = 1                   |
|   **   |   幂   | 又称次方、乘方，2 ** 3 = 8                 |

* 在 Python 中 `*` 运算符还可以用于字符串，计算结果就是使得字符串重复输出指定次数的结果

```python
In [1]: "-" * 50  # * 用于字符串叠加输出
Out[1]: '----------------------------------------'   # 输出结果
```

##### 2.2 算数运算符的优先级

* 和**_数学_**中的运算符的优先级一致，在 Python 中进行数学计算时，同样也是：
    * **先乘除后加减**
    * 同级运算符是 **从左至右** 计算
    * 可以使用 `()` 调整计算的优先级

* 以下表格的算数优先级由高到最低顺序排列

| 运算符   | 描述                   |
| -------- | ---------------------- |
| **       | 幂 (最高优先级)        |
| * / % // | 乘、除、取余数、取整除 |
| + -      | 加法、减法             |

* 例如：
    * `2 + 3 * 5 = 17`
    * `(2 + 3) * 5 = 25`
    * `2 * 3 + 5 = 11`
    * `2 * (3 + 5) = 16`

#### 3. 程序执行原理

##### 1. 计算机中的三大件

计算机中包含有较多的硬件，但是一个程序要运行，有 **三个** 核心的硬件，分别是：

1. **CPU** 
    * 中央处理器，是一块超大规模的集成电路
    * 负责 **处理数据**／**计算**
2. **内存**
    * **临时** 存储数据（断电之后，数据会消失）
    * 速度快
    * 空间小（单位价格高）
3. **硬盘** 
    * **永久** 存储数据
    * 速度慢
    * 空间大（单位价格低）

##### 2. 程序执行的原理

![程序执行的原理](/程序执行原理.png)

1. 程序 **运行之前**，程序是 **保存在硬盘** 中的
2. 当要运行一个程序时
    * 操作系统会首先让 **CPU** 把程序复制到 **内存** 中
    * **CPU** 执行 **内存** 中的 **程序代码**

> **程序要执行，首先要被加载到内存**

###### 2.1 Python 程序执行原理

![python程序的执行原理](/python程序的执行原理.png)

1. 操作系统会首先让 **CPU** 把 **Python 解释器** 的程序复制到 **内存** 中
2. **Python 解释器** 根据语法规则，**从上向下** 让 **CPU** 翻译 **Python 程序中的代码**
3. **CPU** 负责执行翻译完成的代码

######  2.2 Python 的解释器有多大？

* linux下执行以下终端命令可以查看 Python 解释器的大小

```bash
# 1. 确认解释器所在位置
$ which python

# 2. 查看 python 文件大小(只是一个软链接)
$ ls -lh /usr/bin/python

# 3. 查看具体文件大小
$ ls -lh /usr/bin/python2.7
```

> 提示：建立 **软链接** 的目的，是为了方便使用者不用记住使用的解释器是 **哪一个具体版本**


### 二、变量以及分支语句

#### 1.变量

> **程序就是用来处理数据的，而变量就是用来存储数据的**


##### 1.1 变量定义

* 在 Python 中，每个变量 **在使用前都必须赋值**，变量 **赋值以后** 该变量 **才会被创建**
* 等号（=）用来给变量赋值
    * `=` 左边是一个变量名
    * `=` 右边是存储在变量中的值

```python
变量名 = 值
```

##### 1.1.1 变量演练 —— 使用PyCharm

```python
# 定义 qq 号码变量
qq_number = "1234567"

# 定义 qq 密码变量
qq_password = "123"

# 在程序中，如果要输出变量的内容，需要使用 print 函数
print(qq_number)
print(qq_password)
```

> 使用解释器执行，如果要输出变量的内容，必须要要使用 `print` 函数

##### 1.2 变量的类型

* 在内存中创建一个变量，会包括：
    1. 变量的名称
    2. 变量保存的数据
    3. 变量存储数据的类型
    4. 变量的地址（标示）

###### 1.2.1 变量的类型

* 在 `Python` 中定义变量是 **不需要指定类型**（在其他很多高级语言中都需要）
* 数据类型可以分为 **数字型** 和 **非数字型**
* 数字型
    * 整型 (`int`)
    * 浮点型（`float`）
    * 布尔型（`bool`） 
        * 真 `True` `非 0 数` —— **非零即真**
        * 假 `False` `0`
    * 复数型 (`complex`)
        * 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题
* 非数字型
    * 字符串
    * 列表
    * 元组
    * 字典
###### 1.2.1 变量类型的练习 —— 个人信息

**需求**

* 定义变量保存小明的个人信息
* 姓名：**小明**
* 年龄：**18** 岁
* 性别：**是**男生
* 身高：**1.75** 米
* 体重：**75.0** 公斤

> 利用 **单步调试** 确认变量中保存数据的类型
```python
    str 表示是一个字符串类型
    name = "小明"
    # int 表示是一个整数类型
    age = 18
    # bool 表示是一个布尔类型，真 True 或者假 False
    gender = False  # 不是
    # float 表示是一个小数类型，浮点数
    height = 1.75

    weight = 75

    print(name)

```
> ps:在 `Python` 中定义变量不需要指定类型。
>
> * `Python` 可以根据 `=` 等号右侧的值，自动推导出变量中存储数据的类型,所以无需像java一样指定变量类型

##### 1.3 不同类型变量之间的计算

###### 1.3.1**数字型变量** 之间可以直接计算

* 在 Python 中，两个数字型变量是可以直接进行 算数运算的
* 如果变量是 `bool` 型，在计算时
    * `True` 对应的数字是 `1`
    * `False` 对应的数字是 `0`

**演练步骤**

1. 定义整数 `i = 10`
2. 定义浮点数 `f = 10.5`
3. 定义布尔型 `b = True`

* 在 iPython 中，使用上述三个变量相互进行算术运算

###### 1.3.2  **字符串变量** 之间使用 `+` 拼接字符串

* 在 Python 中，字符串之间可以使用 `+` 拼接生成新的字符串

```python
first_name = "三"
last_name = "张"
print(first_name + last_name)

输出: '三张'
```

###### 1.3.3  **字符串变量** 可以和 **整数** 使用 `*` 重复拼接相同的字符串

```python
print("-" * 50)
输出: '--------------------------------------------------'
```

###### 1.3.4 **数字型变量** 和 **字符串** 之间 **不能进行其他计算**

```python
first_name = "zhang"

x = 10

print(x + first_name)
---------------------------------------------------------------------------
TypeError: unsupported operand type(s) for +: 'int' and 'str'
类型错误：`+` 不支持的操作类型：`int` 和 `str`
```

#####  1.4 变量的输入

* 所谓 **输入**，就是 **用代码** **获取** 用户通过 **键盘** 输入的信息
* 例如：去银行取钱，在 ATM 上输入密码
* 在 Python 中，如果要获取用户在 **键盘** 上的输入信息，需要使用到 `input` 函数

######  1.4.1  关于函数

* 一个 **提前准备好的功能**(别人或者自己写的代码)，**可以直接使用**，而 **不用关心内部的细节**
* 目前已经学习过的函数

| 函数     | 说明              |
| -------- | ----------------- |
| print(x) | 将 x 输出到控制台 |
| type(x)  | 查看 x 的变量类型 |


######  1.4.2input 函数实现键盘输入

* 在 Python 中可以使用 `input` 函数从键盘等待用户的输入
* 用户输入的 **任何内容** Python 都认为是一个 **字符串**
* 语法如下：

```python
字符串变量 = input("提示信息：")
```

###### 1.4.3 类型转换函数

| 函数     | 说明                  |
| -------- | --------------------- |
| int(x)   | 将 x 转换为一个整数   |
| float(x) | 将 x 转换到一个浮点数 |

###### 1.4.4 变量输入练习 

**需求**

* **收银员输入** 苹果的价格，单位：**元／斤**
* **收银员输入** 用户购买苹果的重量，单位：**斤**
* 计算并且 **输出** 付款金额
示例：

```python
# 1. 输入苹果单价
price_str = input("请输入苹果价格：")

# 2. 要求苹果重量
weight_str = input("请输入苹果重量：")

# 3. 计算金额
# 1> 将苹果单价转换成小数
price = float(price_str)

# 2> 将苹果重量转换成小数
weight = float(weight_str)

# 3> 计算付款金额
money = price * weight

print(money)
```

##### 1.5 变量的格式化输出

> 苹果单价 `9.00` 元／斤，购买了 `5.00` 斤，需要支付 `45.00` 元

* 在 Python 中可以使用 `print` 函数将信息输出到控制台
* 如果希望输出文字信息的同时，**一起输出** **数据**，就需要使用到 **格式化操作符**
* `%` 被称为 **格式化操作符**，专门用于处理字符串中的格式
    * 包含 `%` 的字符串，被称为 **格式化字符串**
    * `%` 和不同的 **字符** 连用，**不同类型的数据** 需要使用 **不同的格式化字符**

| 格式化字符 | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| %s         | 字符串                                                       |
| %d         | 有符号十进制整数，`%06d` 表示输出的整数显示位数，不足的地方使用 `0` 补全 |
| %f         | 浮点数，`%.2f` 表示小数点后只显示两位                        |
| %%         | 输出 `%`                                                     |

* 语法格式如下：

```python
print("格式化字符串" % 变量1)

print("格式化字符串" % (变量1, 变量2...))
```

###### 1.5.1 格式化输出练习

**需求**

1. 定义字符串变量 `name`，输出 **我的名字叫 小明，请多多关照！**

2. 定义整数变量 `student_no`，输出 **我的学号是 000001**

3. 定义小数 `price`、`weight`、`money`，输出 **苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元**

4. 定义一个小数 `scale`，输出 **数据比例是 10.00%**

   示例：

```python
print("我的名字叫 %s，请多多关照！" % name)
print("我的学号是 %06d" % student_no)
print("苹果单价 %.02f 元／斤，购买 %.02f 斤，需要支付 %.02f 元" % (price, weight, money))
print("数据比例是 %.02f%%" % (scale * 100))
```
####  2、分支语句
#####  2.1  判断语句————if

###### 2.1.1  判断的定义

- 如果 **条件满足**，才能做某件事情，
- 如果 **条件不满足**，就做另外一件事情，或者什么也不做

> 正是因为有了判断，才使得程序世界丰富多彩，充满变化！
>
> **判断语句** 又被称为 “分支语句”，正是因为有了判断，才让程序有了很多的分支

###### 2.1.2 if 判断语句基本语法

在 `Python` 中，**if 语句** 就是用来进行判断的，格式如下：

```python
if 要判断的条件:
    条件成立时，要做的事情
    ……
```

> 注意：代码的缩进为一个 `tab` 键，或者 **4** 个空格 —— **建议使用空格**
>
> - 在 Python 开发中，Tab 和空格不要混用！

**我们可以把整个 if 语句看成一个完整的代码块**


**判断语句演练 —— 判断年龄**

**需求**

1. 定义一个整数变量记录年龄
2. 判断是否满 18 岁 （**>=**）
3. 如果满 18 岁，允许进网吧嗨皮

```python
# 1. 定义年龄变量
age = 18

# 2. 判断是否满 18 岁
# if 语句以及缩进部分的代码是一个完整的代码块
if age >= 18:
    print("可以进网吧嗨皮……")
```

**注意**：

- `if` 语句以及缩进部分是一个 **完整的代码块**

###### 2.1.3 else 处理条件不满足的情况

**思考**

在使用 `if` 判断时，只能做到满足条件时要做的事情。那如果需要在 **不满足条件的时候**，做某些事情，使用 `else`，格式如下：

```python
if 要判断的条件:
    条件成立时，要做的事情
    ……
else:
    条件不成立时，要做的事情
    ……
```

**注意**：

- `if` 和 `else` 语句以及各自的缩进部分共同是一个 **完整的代码块**

 **判断语句演练 —— 判断年龄改进**

**需求**

1. 输入用户年龄
2. 判断是否满 18 岁 （**>=**）
3. 如果满 18 岁，允许进网吧嗨皮
4. 如果未满 18 岁，提示回家写作业

```python
# 1. 输入用户年龄
age = int(input("今年多大了？"))

# 2. 判断是否满 18 岁
# if 语句以及缩进部分的代码是一个完整的语法块
if age >= 18:
    print("可以进网吧嗨皮……")
else:
    print("你还没长大，应该回家写作业！")

```

###### 2.1.4  if 语句进阶之`elif`

- 在开发中，使用 `if` 可以 **判断条件**
- 使用 `else` 可以处理 **条件不成立** 的情况
- 但是，如果希望 **再增加一些条件**，**条件不同，需要执行的代码也不同** 时，就可以使用 `elif`  （类似于Java中的switch ）
- 语法格式如下：

```python
if 条件1:
    条件1满足执行的代码
    ……
elif 条件2:
    条件2满足时，执行的代码
    ……
elif 条件3:
    条件3满足时，执行的代码
    ……
else:
    以上条件都不满足时，执行的代码
    ……

```

**注意**

1. `elif` 和 `else` 都必须和 `if` 联合使用，而不能单独使用
2. 可以将 `if`、`elif` 和 `else` 以及各自缩进的代码，看成一个 **完整的代码块**

###### 2.1.5 `if` 的嵌套

> **elif** 的应用场景是：**同时** 判断 **多个条件**，所有的条件是 **平级** 的

- 在开发中，使用 `if` 进行条件判断，如果希望 **在条件成立的执行语句中** 再 **增加条件判断**，就可以使用 **if 的嵌套**
- **if 的嵌套** 的应用场景就是：**在之前条件满足的前提下，再增加额外的判断**
- **if 的嵌套** 的语法格式，**除了缩进之外** 和之前的没有区别
- 语法格式如下：

```python
if 条件 1:
    条件 1 满足执行的代码
    ……
    
    if 条件 1 基础上的条件 2:
        条件 2 满足时，执行的代码
        ……    
        
    # 条件 2 不满足的处理
    else:
        条件 2 不满足时，执行的代码
        
# 条件 1 不满足的处理
else:
    条件1 不满足时，执行的代码
    ……

```
 **if 的嵌套 演练 —— 火车站安检**

**需求**

1. 定义布尔型变量 `has_ticket` 表示是否有车票
2. 定义整型变量 `knife_length` 表示刀的长度，单位：厘米
3. 首先检查是否有车票，如果有，才允许进行 **安检**
4. 安检时，需要检查刀的长度，判断是否超过 20 厘米
   - 如果超过 20 厘米，提示刀的长度，不允许上车
   - 如果不超过 20 厘米，安检通过
5. 如果没有车票，不允许进门

```python
# 定义布尔型变量 has_ticket 表示是否有车票
has_ticket = True

# 定义整数型变量 knife_length 表示刀的长度，单位：厘米
knife_length = 20

# 首先检查是否有车票，如果有，才允许进行 安检
if has_ticket:
    print("有车票，可以开始安检...")

    # 安检时，需要检查刀的长度，判断是否超过 20 厘米
    # 如果超过 20 厘米，提示刀的长度，不允许上车
    if knife_length >= 20:
        print("不允许携带 %d 厘米长的刀上车" % knife_length)
    # 如果不超过 20 厘米，安检通过
    else:
        print("安检通过，祝您旅途愉快……")

# 如果没有车票，不允许进门
else:
    print("大哥，您要先买票啊")
```

##### 2.2  逻辑运算

- 在程序开发中，通常 **在判断条件时**，会需要同时判断多个条件
- 只有多个条件都满足，才能够执行后续代码，这个时候需要使用到 **逻辑运算符**
- **逻辑运算符** 可以把 **多个条件** 按照 **逻辑** 进行 **连接**，变成 **更复杂的条件**
- Python 中的 **逻辑运算符** 包括：**与  and**／**或  or**／**非  not** 三种

###### 2.2.1  `and`

```
条件1 and 条件2
```

- **与**／**并且**
- 两个条件同时满足，返回 `True`
- 只要有一个不满足，就返回 `False`

| 条件 1 | 条件 2 |  结果  |
| :----: | :----: | :----: |
|  成立  |  成立  |  成立  |
|  成立  | 不成立 | 不成立 |
| 不成立 |  成立  | 不成立 |
| 不成立 | 不成立 | 不成立 |

###### 2.2.2 `or`

```
条件1 or 条件2
```

- **或**／**或者**
- 两个条件只要有一个满足，返回 `True`
- 两个条件都不满足，返回 `False`

| 条件 1 | 条件 2 |  结果  |
| :----: | :----: | :----: |
|  成立  |  成立  |  成立  |
|  成立  | 不成立 |  成立  |
| 不成立 |  成立  |  成立  |
| 不成立 | 不成立 | 不成立 |

###### 2.2.3 `not`

```
not 条件
```

- **非**／**不是**

|  条件  |  结果  |
| :----: | :----: |
|  成立  | 不成立 |
| 不成立 |  成立  |

##### 2.3 运算符

数学符号表链接：[https://zh.wikipedia.org/wiki/数学符号表](https://zh.wikipedia.org/wiki/数学符号表)

###### 2.3.1  算数运算符

- 是完成基本的算术运算使用的符号，用来处理四则运算

| 运算符 |  描述  | 实例                                       |
| :----: | :----: | ------------------------------------------ |
|   +    |   加   | 10 + 20 = 30                               |
|   -    |   减   | 10 - 20 = -10                              |
|   *    |   乘   | 10 * 20 = 200                              |
|   /    |   除   | 10 / 20 = 0.5                              |
|   //   | 取整除 | 返回除法的整数部分（商） 9 // 2 输出结果 4 |
|   %    | 取余数 | 返回除法的余数 9 % 2 = 1                   |
|   **   |   幂   | 又称次方、乘方，2 ** 3 = 8                 |

- 在 Python 中 `*` 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果

```python
In [1]: "-" * 50
Out[1]: '----------------------------------------' 
```

###### 2.3.2  比较（关系）运算符

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| ==     | 检查两个操作数的值是否 **相等**，如果是，则条件成立，返回 True |
| !=     | 检查两个操作数的值是否 **不相等**，如果是，则条件成立，返回 True |
| >      | 检查左操作数的值是否 **大于** 右操作数的值，如果是，则条件成立，返回 True |
| <      | 检查左操作数的值是否 **小于** 右操作数的值，如果是，则条件成立，返回 True |
| >=     | 检查左操作数的值是否 **大于或等于** 右操作数的值，如果是，则条件成立，返回 True |
| <=     | 检查左操作数的值是否 **小于或等于** 右操作数的值，如果是，则条件成立，返回 True |

> Python 2.x 中判断 **不等于** 还可以使用 `<>` 运算符
>
> `!=` 在 Python 2.x 中同样可以用来判断 **不等于**

###### 2.3.3  逻辑运算符

| 运算符 | 逻辑表达式 | 描述                                                         |
| ------ | ---------- | ------------------------------------------------------------ |
| and    | x and y    | 只有 x 和 y 的值都为 True，才会返回 True<br />否则只要 x 或者 y 有一个值为 False，就返回 False |
| or     | x or y     | 只要 x 或者 y 有一个值为 True，就返回 True<br />只有 x 和 y 的值都为 False，才会返回 False |
| not    | not x      | 如果 x 为 True，返回 False<br />如果 x 为 False，返回 True   |

######  2.3.4  赋值运算符

- 在 Python 中，使用 `=` 可以给变量赋值
- 在算术运算时，为了简化代码的编写，`Python` 还提供了一系列的 与 **算术运算符** 对应的 **赋值运算符**
- 注意：**赋值运算符中间不能使用空格**

| 运算符 | 描述                       | 实例                                  |
| ------ | -------------------------- | ------------------------------------- |
| =      | 简单的赋值运算符           | c = a + b 将 a + b 的运算结果赋值为 c |
| +=     | 加法赋值运算符             | c += a 等效于 c = c + a               |
| -=     | 减法赋值运算符             | c -= a 等效于 c = c - a               |
| *=     | 乘法赋值运算符             | c *= a 等效于 c = c * a               |
| /=     | 除法赋值运算符             | c /= a 等效于 c = c / a               |
| //=    | 取整除赋值运算符           | c //= a 等效于 c = c // a             |
| %=     | 取 **模** (余数)赋值运算符 | c %= a 等效于 c = c % a               |
| **=    | 幂赋值运算符               | c **= a 等效于 c = c ** a             |

###### 2.3.5  运算符的优先级

- 以下表格的算数优先级由高到最低顺序排列

| 运算符                   | 描述                   |
| ------------------------ | ---------------------- |
| **                       | 幂 (最高优先级)        |
| * / % //                 | 乘、除、取余数、取整除 |
| + -                      | 加法、减法             |
| <= < > >=                | 比较运算符             |
| == !=                    | 等于运算符             |
| = %= /= //= -= += *= **= | 赋值运算符             |
| not or and               | 逻辑运算符             |

##### 2.4  循环

- 在程序开发中，一共有三种流程方式：

  - **顺序** —— **从上向下**，顺序执行代码
  - **分支** —— 根据条件判断，决定执行代码的 **分支**
  - **循环** —— 让 **特定代码 重复** 执行

###### 2.4.1 `while` 循环基本使用

- 循环的作用就是让 **指定的代码** 重复的执行
- `while` 循环最常用的应用场景就是 **让执行的代码** 按照 **指定的次数** **重复** 执行
- 需求 —— 打印 5 遍 `Hello Python`
- 思考 —— 如果要求打印 100 遍怎么办？

 **`while` 语句基本语法**

```python
初始条件设置 —— 通常是重复执行的 计数器

while 条件(判断 计数器 是否达到 目标次数):
    条件满足时，做的事情1
    条件满足时，做的事情2
    条件满足时，做的事情3
    ...(省略)...
    
    处理条件(计数器 + 1)
```

**注意**：

- `while` 语句以及缩进部分是一个 **完整的代码块**
示例：
**需求**

- 打印 5 遍 Hello Python

```while
# 1. 定义重复次数计数器
i = 1

# 2. 使用 while 判断条件
while i <= 5:
    # 要重复执行的代码
    print("Hello Python")

    # 处理计数器 i
    i = i + 1

print("循环结束后的 i = %d" % i)
```
> 注意：循环结束后，之前定义的计数器条件的数值是依旧存在的

死循环
> 由于程序员的原因，**忘记** 在循环内部 **修改循环的判断条件**，导致循环持续执行，程序无法终止！


###### 2.4.2  break 和 continue

> `break` 和 `continue` 是专门在循环中使用的关键字

- `break` **某一条件满足时**，退出循环，不再执行后续重复的代码
- `continue` **某一条件满足时**，不执行后续重复的代码

> `break` 和 `continue` 只针对 **当前所在循环** 有效

1. **break**

- **在循环过程中**，如果 **某一个条件满足后**，**不** 再希望 **循环继续执行**，可以使用 `break` 退出循环

```python
i = 0

while i < 10:

    # break 某一条件满足时，退出循环，不再执行后续重复的代码
    # i == 3
    if i == 3:
        break

    print(i)

    i += 1

print("over")
```

> `break` 只针对当前所在循环有效

2. **continue**

- **在循环过程中**，如果 **某一个条件满足后**，**不** 希望 **执行循环代码，但是又不希望退出循环**，可以使用 `continue`
- 也就是：在整个循环中，**只有某些条件**，不需要执行循环代码，而其他条件都需要执行

```python
i = 0

while i < 10:

    # 当 i == 7 时，不希望执行需要重复执行的代码
    if i == 7:
        # 在使用 continue 之前，同样应该修改计数器
        # 否则会出现死循环
        i += 1

        continue

    # 重复执行的代码
    print(i)

    i += 1

```

- 需要注意：使用 `continue` 时，**条件处理部分的代码，需要特别注意**，不小心会出现 **死循环**

> `continue` 只针对当前所在循环有效

###### 2.4.3 `while` 循环嵌套

1. 循环嵌套

- `while` 嵌套就是：`while` 里面还有 `while`

```python
while 条件 1:
    条件满足时，做的事情1
    条件满足时，做的事情2
    条件满足时，做的事情3
    ...(省略)...
    
    while 条件 2:
        条件满足时，做的事情1
        条件满足时，做的事情2
        条件满足时，做的事情3
        ...(省略)...
    
        处理条件 2
    
    处理条件 1
```

2. 循环嵌套演练 —— 九九乘法表

 第 1 步：用嵌套打印小星星

**需求**

- 在控制台连续输出五行 `*`，每一行星号的数量依次递增

```
*
**
***
****
*****
```

- 使用字符串 * 打印

```python
# 1. 定义一个计数器变量，从数字1开始，循环会比较方便
row = 1

while row <= 5:

    print("*" * row)

    row += 1

```

 第 2 步：使用循环嵌套打印小星星

**知识点** 对 `print` 函数的使用做一个增强

- 在默认情况下，`print` 函数输出内容之后，会自动在内容末尾增加换行
- 如果不希望末尾增加换行，可以在 `print` 函数输出内容的后面增加 `, end=""`
- 其中 `""` 中间可以指定 `print` 函数输出内容之后，继续希望显示的内容
- 语法格式如下：

```python
# 向控制台输出内容结束之后，不会换行
print("*", end="")

# 单纯的换行
print("")
```

> `end=""` 表示向控制台输出内容结束之后，不会换行

**假设** `Python` **没有提供** 字符串的 `*` 操作 **拼接字符串**

**需求**

- 在控制台连续输出五行 `*`，每一行星号的数量依次递增

```
*
**
***
****
*****
```

**开发步骤**

- 1> 完成 5 行内容的简单输出
- 2> 分析每行内部的 `*` 应该如何处理？
  - 每行显示的星星和当前所在的行数是一致的
  - 嵌套一个小的循环，专门处理每一行中 `列` 的星星显示  

```python
row = 1

while row <= 5:

    # 假设 python 没有提供字符串 * 操作
    # 在循环内部，再增加一个循环，实现每一行的 星星 打印
    col = 1

    while col <= row:
        print("*", end="")

        col += 1

    # 每一行星号输出完成后，再增加一个换行
    print("")

    row += 1

```

 第 3 步： 九九乘法表

**需求** 输出 九九乘法表，格式如下：

```
1 * 1 = 1	
1 * 2 = 2	2 * 2 = 4	
1 * 3 = 3	2 * 3 = 6	3 * 3 = 9	
1 * 4 = 4	2 * 4 = 8	3 * 4 = 12	4 * 4 = 16	
1 * 5 = 5	2 * 5 = 10	3 * 5 = 15	4 * 5 = 20	5 * 5 = 25	
1 * 6 = 6	2 * 6 = 12	3 * 6 = 18	4 * 6 = 24	5 * 6 = 30	6 * 6 = 36	
1 * 7 = 7	2 * 7 = 14	3 * 7 = 21	4 * 7 = 28	5 * 7 = 35	6 * 7 = 42	7 * 7 = 49	
1 * 8 = 8	2 * 8 = 16	3 * 8 = 24	4 * 8 = 32	5 * 8 = 40	6 * 8 = 48	7 * 8 = 56	8 * 8 = 64	
1 * 9 = 9	2 * 9 = 18	3 * 9 = 27	4 * 9 = 36	5 * 9 = 45	6 * 9 = 54	7 * 9 = 63	8 * 9 = 72	9 * 9 = 81

```

**开发步骤**

- 1. 打印 9 行小星星

```
*
**
***
****
*****
******
*******
********
*********
```

- 2. 将每一个 `*` 替换成对应的行与列相乘

```python
# 定义起始行
row = 1

# 最大打印 9 行
while row <= 9:
    # 定义起始列
    col = 1

    # 最大打印 row 列
    while col <= row:

        # end = ""，表示输出结束后，不换行
        # "\t" 可以在控制台输出一个制表符，协助在输出文本时对齐
        print("%d * %d = %d" % (col, row, row * col), end="\t")

        # 列数 + 1
        col += 1

    # 一行打印完成的换行
    print("")

    # 行数 + 1
    row += 1

```

**字符串中的转义字符**

- `\t` 在控制台输出一个 **制表符**，协助在输出文本时 **垂直方向** 保持对齐
- `\n` 在控制台输出一个 **换行符**

> **制表符** 的功能是在不使用表格的情况下在 **垂直方向** 按列对齐文本

| 转义字符 | 描述       |
| -------- | ---------- |
| \\\\     | 反斜杠符号 |
| \\'      | 单引号     |
| \\"      | 双引号     |
| \n       | 换行       |
| \t       | 横向制表符 |
| \r       | 回车       |



#### 3、 高级变量类型

- Python 中数据类型可以分为 **数字型** 和 **非数字型**
- 数字型
  - 整型 (`int`)
  - 浮点型（`float`）
  - 布尔型（`bool`） 
    - 真 `True` `非 0 数` —— **非零即真**
    - 假 `False` `0`
  - 复数型 (`complex`)
    - 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题
- 非数字型
  - 字符串
  - 列表
  - 元组
  - 字典
- 在 `Python` 中，所有 **非数字型变量** 都支持以下特点：
  1. 都是一个 **序列** `sequence`，也可以理解为 **容器**
  2. **取值** `[]`
  3. **遍历** `for in`
  4. **计算长度**、**最大/最小值**、**比较**、**删除**
  5. **链接** `+` 和 **重复** `*`
  6. **切片**

##### 3.1 列表

######  3.1.1 列表的定义

- `List`（列表） 是 `Python` 中使用 **最频繁** 的数据类型，在其他语言中通常叫做 **数组**
- 专门用于存储 **一串信息**
- 列表用 `[]` 定义，**数据** 之间使用 `,` 分隔
- 列表的 **索引** 从 `0` 开始
  - **索引** 就是数据在 **列表** 中的位置编号，**索引** 又可以被称为 **下标**

> 注意：从列表中取值时，如果 **超出索引范围**，程序会报错

```python
name_list = ["zhangsan", "lisi", "wangwu"]
```
######  3.1.2 列表常用操作

- 定义一个 **列表**，例如：`name_list = []`
- 输入 `name_list.` 按下 `TAB` 键，会提示 **列表** 能够使用的 **方法** 如下：

```
name_list.append   name_list.count    name_list.insert   name_list.reverse
name_list.clear    name_list.extend   name_list.pop      name_list.sort
name_list.copy     name_list.index    name_list.remove 
```

| 序号 | 分类 | 关键字 / 函数 / 方法    | 说明               |
| ---- | ---- | ----------------------- | ------------------ |
| 1    | 增加 | 列表.insert(索引, 数据) | 在指定位置插入数据 |

|  |  | 列表.append(数据) | 在末尾追加数据
|  |  | 列表.extend(列表2) | 将列表2 的数据追加到列表 | 
| 2 | 修改 | 列表[索引] = 数据 | 修改指定索引的数据 |
| 3 | 删除 | del 列表[索引] | 删除指定索引的数据 |
|  |  | 列表.remove[数据] | 删除第一个出现的指定数据 |
|  |  | 列表.pop | 删除末尾数据 |
|  |  | 列表.pop(索引) | 删除指定索引数据 |
|  |  | 列表.clear | 清空列表 |
| 4 | 统计 | len(列表) | 列表长度 |
|  |  | 列表.count(数据) | 数据在列表中出现的次数 |
| 5 | 排序 | 列表.sort() | 升序排序 |
|  |  | 列表.sort(reverse=True) | 降序排序 |
|  |  | 列表.reverse() | 逆序、反转 |

1、 del关键字
- 使用 `del` 关键字(`delete`) 同样可以删除列表中元素
- `del` 关键字本质上是用来 **将一个变量从内存中删除的**
- 如果使用 `del` 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了

```python
del name_list[1]
```

> 在日常开发中，要从列表删除数据，建议 **使用列表提供的方法**

2、 关键字、函数和方法

- **关键字** 是 Python 内置的、具有特殊意义的标识符

```python
In [1]: import keyword
In [2]: print(keyword.kwlist)
In [3]: print(len(keyword.kwlist))
```

> 关键字后面不需要使用括号

- **函数** 封装了独立功能，可以直接调用

```python
函数名(参数)
```

######  3.1.3 循环遍历列表

- **遍历** 就是 **从头到尾** **依次** 从 **列表** 中获取数据
  - 在 **循环体内部** 针对 **每一个元素**，执行相同的操作
- 在 `Python` 中为了提高列表的遍历效率，专门提供的 **迭代 iteration 遍历**
- 使用 `for` 就能够实现迭代遍历

```python
# for 循环内部使用的变量 in 列表
for name in name_list:

    循环内部针对列表元素进行操作
    print(name)

```
##### 3.2 元组

###### 3.2.1 元组的定义

- `Tuple`（元组）与列表类似，不同之处在于元组的 **元素不能修改**
  - **元组** 表示多个元素组成的序列
  - **元组** 在 `Python` 开发中，有特定的应用场景
- 用于存储 **一串 信息**，**数据** 之间使用 `,` 分隔
- 元组用 `()` 定义
- 元组的 **索引** 从 `0` 开始
  - **索引** 就是数据在 **元组** 中的位置编号

```python
info_tuple = ("zhangsan", 18, 1.75)
```

1、  创建空元组

```python
info_tuple = ()

```

2、  元组中 **只包含一个元素** 时，需要 **在元素后面添加逗号**

```python
info_tuple = (50, )

```
######  3.2.2 元组常用操作

```python
info.count  info.index

```

> 有关 **元组** 的 **常用操作** 可以参照上图练习

###### 3.2.3 循环遍历

- **取值** 就是从 **元组** 中获取存储在指定位置的数据
- **遍历** 就是 **从头到尾** **依次** 从 **元组** 中获取数据

```python
# for 循环内部使用的变量 in 元组
for item in info:

    循环内部针对元组元素进行操作
    print(item)


```

> - 在 `Python` 中，可以使用 `for` 循环遍历所有非数字型类型的变量：**列表**、**元组**、**字典** 以及 **字符串**
> - 提示：在实际开发中，除非 **能够确认元组中的数据类型**，否则针对元组的循环遍历需求并不是很多

######  3.2.4 元组和列表之间的转换

- 使用 `list` 函数可以把元组转换成列表

```python
list(元组) 

```

- 使用 `tuple` 函数可以把列表转换成元组

```python
tuple(列表)

```

##### 3.3 字典

######  3.3.1 字典的定义

- `dictionary`（字典） 是 **除列表以外** `Python` 之中 **最灵活** 的数据类型
- 字典同样可以用来 **存储多个数据**
  - 通常用于存储 **描述一个 `物体` 的相关信息** 
- 和列表的区别
  - **列表** 是 **有序** 的对象集合
  - **字典** 是 **无序** 的对象集合
- 字典用 `{}` 定义
- 字典使用 **键值对** 存储数据，键值对之间使用 `,` 分隔
  - **键** `key` 是索引
  - **值** `value` 是数据
  - **键** 和 **值** 之间使用 `:` 分隔
  - **键必须是唯一的**
  - **值** 可以取任何数据类型，但 **键** 只能使用 **字符串**、**数字**或 **元组**

```python
xiaoming = {"name": "小明",
            "age": 18,
            "gender": True,
            "height": 1.75}

```

######  3.3.2 字典常用操作

-定义一个 **字典**，例如：`xiaoming = {}`
- 输入 `xiaoming.` 按下 `TAB` 键， 会提示 **字典** 能够使用的函数如下：

```
In [1]: xiaoming.
xiaoming.clear       xiaoming.items       xiaoming.setdefault
xiaoming.copy        xiaoming.keys        xiaoming.update
xiaoming.fromkeys    xiaoming.pop         xiaoming.values
xiaoming.get         xiaoming.popitem    

```

######  3.3.3 循环遍历

- **遍历** 就是 **依次** 从 **字典** 中获取所有键值对

```python
# for 循环内部使用的 `key 的变量` in 字典
for k in xiaoming:

    print("%s: %s" % (k, xiaoming[k]))

```

> 提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多

##### 3.4 字符串

###### 3.4.1 字符串的定义

- **字符串** 就是 **一串字符**，是编程语言中表示文本的数据类型
- 在 Python 中可以使用 **一对双引号** `"` 或者 **一对单引号** `'` 定义一个字符串
  - 虽然可以使用 `\"` 或者 `\'` 做字符串的转义，但是在实际开发中：
    - 如果字符串内部需要使用 `"`，可以使用 `'` 定义字符串
    - 如果字符串内部需要使用 `'`，可以使用 `"` 定义字符串
- 可以使用 **索引** 获取一个字符串中 **指定位置的字符**，索引计数从 **0** 开始
- 也可以使用 `for` **循环遍历** 字符串中每一个字符

> 大多数编程语言都是用 `"` 来定义字符串

```python
string = "Hello Python"

for c in string:
    print(c)


```

###### 3.4.2 字符串的常用操作

- 定义一个 **字符串**，例如：`hello_str = ""`
- 输入 `hello_str.` 按下 `TAB` 键， 会提示 **字符串** 能够使用的 **方法** 如下：

```
In [1]: hello_str.
hello_str.capitalize    hello_str.isidentifier  hello_str.rindex
hello_str.casefold      hello_str.islower       hello_str.rjust
hello_str.center        hello_str.isnumeric     hello_str.rpartition
hello_str.count         hello_str.isprintable   hello_str.rsplit
hello_str.encode        hello_str.isspace       hello_str.rstrip
hello_str.endswith      hello_str.istitle       hello_str.split
hello_str.expandtabs    hello_str.isupper       hello_str.splitlines
hello_str.find          hello_str.join          hello_str.startswith
hello_str.format        hello_str.ljust         hello_str.strip
hello_str.format_map    hello_str.lower         hello_str.swapcase
hello_str.index         hello_str.lstrip        hello_str.title
hello_str.isalnum       hello_str.maketrans     hello_str.translate
hello_str.isalpha       hello_str.partition     hello_str.upper
hello_str.isdecimal     hello_str.replace       hello_str.zfill
hello_str.isdigit       hello_str.rfind

```

> 提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！

 1. 判断类型 - 9

| 方法               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| string.isspace()   | 如果 string 中只包含空格，则返回 True                        |
| string.isalnum()   | 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True |
| string.isalpha()   | 如果 string 至少有一个字符并且所有字符都是字母则返回 True    |
| string.isdecimal() | 如果 string 只包含数字则返回 True，`全角数字`                |
| string.isdigit()   | 如果 string 只包含数字则返回 True，`全角数字`、`⑴`、`\u00b2` |
| string.isnumeric() | 如果 string 只包含数字则返回 True，`全角数字`，`汉字数字`    |
| string.istitle()   | 如果 string 是标题化的(每个单词的首字母大写)则返回 True      |
| string.islower()   | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True |
| string.isupper()   | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True |

2. 查找和替换 - 7

| 方法                                                    | 说明                                                         |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| string.startswith(str)                                  | 检查字符串是否是以 str 开头，是则返回 True                   |
| string.endswith(str)                                    | 检查字符串是否是以 str 结束，是则返回 True                   |
| string.find(str, start=0, end=len(string))              | 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 `-1` |
| string.rfind(str, start=0, end=len(string))             | 类似于 find()，不过是从右边开始查找                          |
| string.index(str, start=0, end=len(string))             | 跟 find() 方法类似，不过如果 str 不在 string 会报错          |
| string.rindex(str, start=0, end=len(string))            | 类似于 index()，不过是从右边开始                             |
| string.replace(old_str, new_str, num=string.count(old)) | 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 |

3. 大小写转换 - 5

| 方法                | 说明                             |
| ------------------- | -------------------------------- |
| string.capitalize() | 把字符串的第一个字符大写         |
| string.title()      | 把字符串的每个单词首字母大写     |
| string.lower()      | 转换 string 中所有大写字符为小写 |
| string.upper()      | 转换 string 中的小写字母为大写   |
| string.swapcase()   | 翻转 string 中的大小写           |

4. 文本对齐 - 3

| 方法                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| string.ljust(width)  | 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 |
| string.rjust(width)  | 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 |
| string.center(width) | 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串  |

5. 去除空白字符 - 3

| 方法            | 说明                               |
| --------------- | ---------------------------------- |
| string.lstrip() | 截掉 string 左边（开始）的空白字符 |
| string.rstrip() | 截掉 string 右边（末尾）的空白字符 |
| string.strip()  | 截掉 string 左右两边的空白字符     |

6. 拆分和连接 - 5

| 方法                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| string.partition(str)     | 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) |
| string.rpartition(str)    | 类似于 partition() 方法，不过是从右边开始查找                |
| string.split(str="", num) | 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 '\r', '\t', '\n' 和空格 |
| string.splitlines()       | 按照行('\r', '\n', '\r\n')分隔，返回一个包含各行作为元素的列表 |
| string.join(seq)          | 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 |

###### 3.4.3 字符串的切片

- **切片** 方法适用于 **字符串**、**列表**、**元组**
  - **切片** 使用 **索引值** 来限定范围，从一个大的 **字符串** 中 **切出** 小的 **字符串**
  - **列表** 和 **元组** 都是 **有序** 的集合，都能够 **通过索引值** 获取到对应的数据
  - **字典** 是一个 **无序** 的集合，是使用 **键值对** 保存数据

- 切片方法：
```
字符串[开始索引:结束索引:步长]

```

**注意**：

1. 指定的区间属于 **左闭右开** 型 `[开始索引,  结束索引)` => `开始索引 >= 范围 < 结束索引`
   - 从 `起始` 位开始，到 **`结束`位的前一位** 结束（**不包含结束位本身**)
2. 从头开始，**开始索引** **数字可以省略，冒号不能省略**
3. 到末尾结束，**结束索引** **数字可以省略，冒号不能省略**
4. 步长默认为 `1`，如果连续切片，**数字和冒号都可以省略**

6. 索引的顺序和倒序

- 在 Python 中不仅支持 **顺序索引**，同时还支持 **倒序索引**
- 所谓倒序索引就是 **从右向左** 计算索引
  - 最右边的索引值是 **-1**，依次递减

**演练需求**

- 1. 截取从 2 ~ 5 位置 的字符串
- 2. 截取从 2 ~ `末尾` 的字符串
- 3. 截取从 `开始` ~ 5 位置 的字符串
- 4. 截取完整的字符串
- 5. 从开始位置，每隔一个字符截取字符串
- 6. 从索引 1 开始，每隔一个取一个
- 7. 截取从 2 ~ `末尾 - 1` 的字符串
- 8. 截取字符串末尾两个字符
- 9. 字符串的逆序（面试题）

**答案**

```
num_str = "0123456789"

# 1. 截取从 2 ~ 5 位置 的字符串
print(num_str[2:6])

# 2. 截取从 2 ~ `末尾` 的字符串
print(num_str[2:])

# 3. 截取从 `开始` ~ 5 位置 的字符串
print(num_str[:6])

# 4. 截取完整的字符串
print(num_str[:])

# 5. 从开始位置，每隔一个字符截取字符串
print(num_str[::2])

# 6. 从索引 1 开始，每隔一个取一个
print(num_str[1::2])

# 倒序切片
# -1 表示倒数第一个字符
print(num_str[-1])

# 7. 截取从 2 ~ `末尾 - 1` 的字符串
print(num_str[2:-1])

# 8. 截取字符串末尾两个字符
print(num_str[-2:])

# 9. 字符串的逆序（面试题）
print(num_str[::-1])


```

##### 3.5  公共方法

###### 3.5.1 Python 内置函数

Python 包含了以下内置函数：

| 函数              | 描述                              | 备注                        |
| ----------------- | --------------------------------- | --------------------------- |
| len(item)         | 计算容器中元素个数                |                             |
| del(item)         | 删除变量                          | del 有两种方式              |
| max(item)         | 返回容器中元素最大值              | 如果是字典，只针对 key 比较 |
| min(item)         | 返回容器中元素最小值              | 如果是字典，只针对 key 比较 |
| cmp(item1, item2) | 比较两个值，-1 小于/0 相等/1 大于 | Python 3.x 取消了 cmp 函数  |

**注意**

- **字符串** 比较符合以下规则： "0" < "A" < "a"

1. 切片

| 描述 | Python 表达式      | 结果    | 支持的数据类型     |
| :--: | ------------------ | ------- | ------------------ |
| 切片 | "0123456789"[::-2] | "97531" | 字符串、列表、元组 |

- **切片** 使用 **索引值** 来限定范围，从一个大的 **字符串** 中 **切出** 小的 **字符串**
- **列表** 和 **元组** 都是 **有序** 的集合，都能够 **通过索引值** 获取到对应的数据
- **字典** 是一个 **无序** 的集合，是使用 **键值对** 保存数据

###### 3.5.2  运算符

|    运算符    | Python 表达式         | 结果                         | 描述           | 支持的数据类型           |
| :----------: | --------------------- | ---------------------------- | -------------- | ------------------------ |
|      +       | [1, 2] + [3, 4]       | [1, 2, 3, 4]                 | 合并           | 字符串、列表、元组       |
|      *       | ["Hi!"] * 4           | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] | 重复           | 字符串、列表、元组       |
|      in      | 3 in (1, 2, 3)        | True                         | 元素是否存在   | 字符串、列表、元组、字典 |
|    not in    | 4 not in (1, 2, 3)    | True                         | 元素是否不存在 | 字符串、列表、元组、字典 |
| > >= == < <= | (1, 2, 3) < (2, 2, 3) | True                         | 元素比较       | 字符串、列表、元组       |

**注意**

- `in` 在对 **字典** 操作时，判断的是 **字典的键**
- `in` 和 `not in` 被称为 **成员运算符**

1. 成员运算符

成员运算符用于 **测试** 序列中是否包含指定的 **成员**

| 运算符 | 描述                                                  | 实例                              |
| ------ | ----------------------------------------------------- | --------------------------------- |
| in     | 如果在指定的序列中找到值返回 True，否则返回 False     | `3 in (1, 2, 3)` 返回 `True`      |
| not in | 如果在指定的序列中没有找到值返回 True，否则返回 False | `3 not in (1, 2, 3)` 返回 `False` |

注意：在对 **字典** 操作时，判断的是 **字典的键**

###### 3.5.3 完整的 for 循环语法

- 在 `Python` 中完整的 `for 循环` 的语法如下：

```python
for 变量 in 集合:
    
    循环体代码
else:
    没有通过 break 退出循环，循环结束后，会执行的代码

```

####  4、函数与模块

#####  4.1 函数

- 所谓**函数**，就是把 **具有独立功能的代码块** 组织为一个小模块，在需要的时候 **调用**
- 函数的使用包含两个步骤：
  1. 定义函数 —— **封装** 独立的功能
  2. 调用函数 —— 享受 **封装** 的成果
- **函数的作用**，在开发程序时，使用函数可以提高编写的效率以及代码的 **重用**

###### 4.1.1 函数的定义

定义函数的格式如下：

```python
def 函数名():

    函数封装的代码
    ……
```

1. `def` 是英文 `define` 的缩写
2. **函数名称** 应该能够表达 **函数封装代码** 的功能，方便后续的调用
3. **函数名称** 的命名应该 **符合** **标识符的命名规则**
   - 可以由 **字母**、**下划线** 和 **数字** 组成
   - **不能以数字开头**
   - **不能与关键字重名**

###### 4.1.2 函数调用

调用函数很简单的，通过 `函数名()` 即可完成对函数的调用

###### 4.1.3 第一个函数演练

**需求**

- 1. 编写一个打招呼 `say_hello` 的函数，封装三行打招呼的代码
- 2. 在函数下方调用打招呼的代码

```python
name = "小明"


# 解释器知道这里定义了一个函数
def say_hello():
    print("hello 1")
    print("hello 2")
    print("hello 3")

print(name)
# 只有在调用函数时，之前定义的函数才会被执行
# 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码
say_hello()

print(name)

```

> 用 **单步执行 F8 和 F7** 观察以下代码的执行过程

- 定义好函数之后，只表示这个函数封装了一段代码而已
- 如果不主动调用函数，函数是不会主动执行的
- 
- 能否将 **函数调用** 放在 **函数定义** 的上方？
  - 不能！
  - 因为在 **使用函数名** 调用函数之前，必须要保证 `Python` 已经知道函数的存在
  - 否则控制台会提示 `NameError: name 'say_hello' is not defined` (**名称错误：say_hello 这个名字没有被定义**)

###### 4.1.4 PyCharm 的调试工具

- **F8 Step Over** 可以单步执行代码，会把函数调用看作是一行代码直接执行
- **F7 Step Into** 可以单步执行代码，如果是函数，会进入函数内部 

###### 4.1.5 函数的文档注释

- 在开发中，如果希望给函数添加注释，应该在 **定义函数** 的下方，使用 **连续的三对引号**
- 在 **连续的三对引号** 之间编写对函数的说明文字
- 在 **函数调用** 位置，使用快捷键 `CTRL + Q` 可以查看函数的说明信息

> 注意：因为 **函数体相对比较独立**，**函数定义的上方**，应该和其他代码（包括注释）保留 **两个空行**

##### 4.2  函数的参数

###### 4.2.1  函数参数的使用

- 在函数名的后面的小括号内部填写 **参数**
- 多个参数之间使用 `,` 分隔

```python
def sum_2_num(num1, num2):

    result = num1 + num2
    
    print("%d + %d = %d" % (num1, num2, result))

sum_2_num(50, 20)

```

###### 4.2.2  参数的作用

- **函数**，把 **具有独立功能的代码块** 组织为一个小模块，在需要的时候 **调用**
- **函数的参数**，增加函数的 **通用性**，针对 **相同的数据处理逻辑**，能够 **适应更多的数据**
  1. 在函数 **内部**，把参数当做 **变量** 使用，进行需要的数据处理
  2. 函数调用时，按照函数定义的**参数顺序**，把 **希望在函数内部处理的数据**，**通过参数** 传递

###### 4.2.3 形参和实参

- **形参**：**定义** 函数时，小括号中的参数，是用来接收参数用的，在函数内部 **作为变量使用**
- **实参**：**调用** 函数时，小括号中的参数，是用来把数据传递到 **函数内部** 用的

##### 4.3  函数的返回值

- 在程序开发中，有时候，会希望 **一个函数执行结束后，告诉调用者一个结果**，以便调用者针对具体的结果做后续的处理
- **返回值** 是函数 **完成工作**后，**最后** 给调用者的 **一个结果**
- 在函数中使用 `return` 关键字可以返回结果
- 调用函数一方，可以 **使用变量** 来 **接收** 函数的返回结果

> 注意：`return` 表示返回，后续的代码都不会被执行

```python
def sum_2_num(num1, num2):
    """对两个数字的求和"""

    return num1 + num2

# 调用函数，并使用 result 变量接收计算结果
result = sum_2_num(10, 20)

print("计算结果是 %d" % result)

```

##### 4.4 函数的嵌套调用

- 一个函数里面 **又调用** 了 **另外一个函数**，这就是 **函数嵌套调用**
- 如果函数 `test2` 中，调用了另外一个函数 `test1`
  - 那么执行到调用 `test1` 函数时，会先把函数 `test1` 中的任务都执行完
  - 才会回到 `test2` 中调用函数 `test1` 的位置，继续执行后续的代码

```python
def test1():

    print("*" * 50)
    print("test 1")
    print("*" * 50)


def test2():

    print("-" * 50)
    print("test 2")
    
    test1()
    
    print("-" * 50)

test2()

```

##### 4.5  模块

> **模块是 Python 程序架构的一个核心概念**

- **模块** 就好比是 **工具包**，要想使用这个工具包中的工具，就需要 **导入 import** 这个模块
- 每一个以扩展名 `py` 结尾的 `Python` 源代码文件都是一个 **模块**
- 在模块中定义的 **全局变量** 、 **函数** 都是模块能够提供给外界直接使用的工具

- 可以 **在一个 Python 文件** 中 **定义 变量 或者 函数**
- 然后在 **另外一个文件中** 使用 `import` 导入这个模块
- 导入之后，就可以使用 `模块名.变量` / `模块名.函数` 的方式，使用这个模块中定义的变量或者函数

> **模块**可以让 **曾经编写过的代码** 方便的被 **复用**！

###### 4.5.1 模块名也是一个标识符

- 标示符可以由 **字母**、**下划线** 和 **数字** 组成
- **不能以数字开头**
- **不能与关键字重名**

> 注意：如果在给 Python 文件起名时，**以数字开头** 是无法在 `PyCharm` 中通过导入这个模块的

######  4.5.2  Pyc 文件

> `C` 是 `compiled` **编译过** 的意思

**操作步骤**

1. 浏览程序目录会发现一个 `__pycache__` 的目录
2. 目录下会有一个 `hm_10_分隔线模块.cpython-35.pyc` 文件，`cpython-35` 表示 `Python` 解释器的版本
3. 这个 `pyc` 文件是由 Python 解释器将 **模块的源码** 转换为 **字节码**
   - `Python` 这样保存 **字节码** 是作为一种启动 **速度的优化**

**字节码**

- `Python` 在解释源程序时是分成两个步骤的
  1. 首先处理源代码，**编译** 生成一个二进制 **字节码**
  2. 再对 **字节码** 进行处理，才会生成 CPU 能够识别的 **机器码**
- 有了模块的字节码文件之后，下一次运行程序时，如果在 **上次保存字节码之后** 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤
- 当 `Python` 重编译时，它会自动检查源文件和字节码文件的时间戳
- 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建

> 提示：有关模块以及模块的其他导入方式，后续课程还会逐渐展开！
>
> **模块是 Python 程序架构的一个核心概念**


#### 5. 变量与函数进阶

##### 5.1变量进阶

###### 5.1.1 变量的引用

> - 变量 和 数据 都是保存在 **内存** 中的
> - 在 `Python` 中 **函数 的 参数传递** 以及 **返回值** 都是靠 **引用** 传递的

在 `Python` 中

- **变量** 和 **数据** 是分开存储的
- **数据** 保存在内存中的一个位置
- **变量** 中保存着数据在内存中的地址
- **变量** 中 **记录数据的地址**，就叫做 **引用**
- 使用 `id()` 函数可以查看变量中保存数据所在的 **内存地址**

> 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 **修改了数据的引用**
>
> - 变量 **不再** 对之前的数据引用
> - 变量 **改为** 对新赋值的数据引用

######  5.1.2 函数的参数和返回值的传递

在 `Python` 中，函数的 **实参**/**返回值** 都是是靠 **引用** 来传递来的

```python
def test(num):

    print("-" * 50)
    print("%d 在函数内的内存地址是 %x" % (num, id(num)))

    result = 100

    print("返回值 %d 在内存中的地址是 %x" % (result, id(result)))
    print("-" * 50)

    return  result

a = 10
print("调用函数前 内存地址是 %x" % id(a))

r = test(a)

print("调用函数后 实参内存地址是 %x" % id(a))
print("调用函数后 返回值内存地址是 %x" % id(r))

```

######  5.1.3  可变和不可变类型

- **不可变类型**，内存中的数据不允许被修改：
  - 数字类型 `int`, `bool`, `float`, `complex`, `long(2.x)`
  - 字符串 `str`
  - 元组 `tuple`
- **可变类型**，内存中的数据可以被修改：
  - 列表 `list`
  - 字典 `dict`

```python
demo_list = [1, 2, 3]

print("定义列表后的内存地址 %d" % id(demo_list))

demo_list.append(999)
demo_list.pop(0)
demo_list.remove(2)
demo_list[0] = 10

print("修改数据后的内存地址 %d" % id(demo_list))

demo_dict = {"name": "小明"}

print("定义字典后的内存地址 %d" % id(demo_dict))

demo_dict["age"] = 18
demo_dict.pop("name")
demo_dict["name"] = "老王"

print("修改数据后的内存地址 %d" % id(demo_dict))

```

> 注意：字典的 `key` **只能使用不可变类型的数据**

**注意**

1. **可变类型**的数据变化，是通过 **方法** 来实现的
2. 如果给一个可变类型的变量，赋值了一个新的数据，**引用会修改**
   - 变量 **不再** 对之前的数据引用
   - 变量 **改为** 对新赋值的数据引用

###### 5.1.4  哈希 `(hash)`

- `Python` 中内置有一个名字叫做 `hash(o)` 的函数
  - 接收一个 **不可变类型** 的数据作为 **参数**
  - **返回** 结果是一个 **整数**
- `哈希` 是一种 **算法**，其作用就是提取数据的 **特征码（指纹）**
  - **相同的内容** 得到 **相同的结果**
  - **不同的内容** 得到 **不同的结果**
- 在 `Python` 中，设置字典的 **键值对** 时，会首先对 `key` 进行 `hash` 已决定如何在内存中保存字典的数据，以方便 **后续** 对字典的操作：**增、删、改、查**
  - 键值对的 `key` 必须是不可变类型数据
  - 键值对的 `value` 可以是任意类型的数据

######  5.1.5  局部变量和全局变量

- **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**
- **全局变量** 是在 **函数外部定义** 的变量（没有定义在某一个函数内），**所有函数** 内部 **都可以使用这个变量**

> 提示：在其他的开发语言中，大多 **不推荐使用全局变量** —— 可变范围太大，导致程序不好维护！

一、 局部变量

- **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**
- 函数执行结束后，**函数内部的局部变量，会被系统回收**
- 不同的函数，可以定义相同的名字的局部变量，但是 **彼此之间** 不会产生影响

1. 局部变量的作用

- 在函数内部使用，**临时** 保存 **函数内部需要使用的数据**

```python
def demo1():

    num = 10

    print(num)

    num = 20

    print("修改后 %d" % num)


def demo2():

    num = 100

    print(num)

demo1()
demo2()

print("over")

```

2. 局部变量的生命周期

- 所谓 **生命周期** 就是变量从 **被创建** 到 **被系统回收** 的过程
- **局部变量** 在 **函数执行时** 才会被创建
- **函数执行结束后** 局部变量 **被系统回收**
- **局部变量在生命周期** 内，可以用来存储 **函数内部临时使用到的数据**

二、 全局变量

- **全局变量** 是在 **函数外部定义** 的变量，所有函数内部都可以使用这个变量

```python
# 定义一个全局变量
num = 10


def demo1():

    print(num)


def demo2():

    print(num)

demo1()
demo2()

print("over")

```

**注意**：函数执行时，**需要处理变量时** 会：

1. **首先** 查找 **函数内部** 是否存在 **指定名称 的局部变量**，**如果有，直接使用**
2. 如果没有，查找 **函数外部** 是否存在 **指定名称 的全局变量**，**如果有，直接使用**
3. 如果还没有，程序报错！

 1) 函数不能直接修改 `全局变量的引用`

- **全局变量** 是在 **函数外部定义** 的变量（没有定义在某一个函数内），**所有函数** 内部 **都可以使用这个变量**

> 提示：在其他的开发语言中，大多 **不推荐使用全局变量** —— 可变范围太大，导致程序不好维护！

- 在函数内部，可以 **通过全局变量的引用获取对应的数据**
- 但是，**不允许直接修改全局变量的引用** —— 使用赋值语句修改全局变量的值

```python
num = 10


def demo1():

    print("demo1" + "-" * 50)

    # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已
    num = 100
    print(num)


def demo2():

    print("demo2" + "-" * 50)
    print(num)

demo1()
demo2()

print("over")

```

> 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值

2) 在函数内部修改全局变量的值

- 如果在函数中需要修改全局变量，需要使用 `global` 进行声明

```python
num = 10


def demo1():

    print("demo1" + "-" * 50)

    # global 关键字，告诉 Python 解释器 num 是一个全局变量
    global num
    # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已
    num = 100
    print(num)


def demo2():

    print("demo2" + "-" * 50)
    print(num)

demo1()
demo2()

print("over")

```
3) 全局变量定义的位置

- 为了保证所有的函数都能够正确使用到全局变量，应该 **将全局变量定义在其他函数的上方**

```python
a = 10


def demo():
    print("%d" % a)
    print("%d" % b)
    print("%d" % c)

b = 20
demo()
c = 30

```

**注意**

- 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！


4) 全局变量命名的建议

- 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：
- 全局变量名前应该增加 `g_` 或者 `gl_` 的前缀

> 提示：具体的要求格式，各公司要求可能会有些差异



##### 5.2 函数进阶


###### 5.2.1 函数参数和返回值的作用

函数根据 **有没有参数** 以及 **有没有返回值**，可以 **相互组合**，一共有 **4 种** 组合形式

1. 无参数，无返回值
2. 无参数，有返回值
3. 有参数，无返回值
4. 有参数，有返回值

![1558945320039](/1558945320039.png)

> 定义函数时，**是否接收参数，或者是否返回结果**，是根据 **实际的功能需求** 来决定的！

1. 如果函数 **内部处理的数据不确定**，就可以将外界的数据以参数传递到函数内部
2. 如果希望一个函数 **执行完成后，向外界汇报执行结果**，就可以增加函数的返回值


###### 5.2.2 函数的返回值 进阶

- 在程序开发中，有时候，会希望 **一个函数执行结束后，告诉调用者一个结果**，以便调用者针对具体的结果做后续的处理
- **返回值** 是函数 **完成工作**后，**最后** 给调用者的 **一个结果**
- 在函数中使用 `return` 关键字可以返回结果
- 调用函数一方，可以 **使用变量** 来 **接收** 函数的返回结果

> 问题：一个函数执行后能否返回多个结果？

示例 —— 温度和湿度测量

- 假设要开发一个函数能够同时返回当前的温度和湿度
- **先完成返回温度**的功能如下：

```python
def measure():
    """返回当前的温度"""
    
    print("开始测量...")
    temp = 39
    print("测量结束...")
    
    return temp

result = measure()
print(result)
```

- 在利用 **元组** 在返回温度的同时，也能够返回 **湿度**
- 改造如下：

```python
def measure():
    """返回当前的温度"""

    print("开始测量...")
    temp = 39
    wetness = 10
    print("测量结束...")

    return (temp, wetness)
```

> 提示：如果一个函数返回的是元组，括号可以省略

**技巧** 

- 在 `Python` 中，可以 **将一个元组** 使用 **赋值语句** 同时赋值给 **多个变量**
- 注意：变量的数量需要和元组中的元素数量保持一致

```python
result = temp, wetness = measure()
```

面试题 —— 交换两个数字

**题目要求**

1. 有两个整数变量 `a = 6`, `b = 100`
2. 不使用其他变量，**交换两个变量的值**

 解法 1 —— 使用其他变量

```python
# 解法 1 - 使用临时变量
c = b
b = a
a = c
```

 解法 2 —— 不使用临时变量

```python
# 解法 2 - 不使用临时变量
a = a + b
b = a - b
a = a - b
```

解法 3 —— Python 专有，利用元组

```python
a, b = b, a
```

###### 5.2.3 函数的参数 进阶

1. 不可变和可变的参数

> 问题 1：在函数内部，针对参数使用 **赋值语句**，会不会影响调用函数时传递的 **实参变量**？ —— 不会！

- 无论传递的参数是 **可变** 还是 **不可变** 
  - 只要 **针对参数** 使用 **赋值语句**，会在 **函数内部** 修改 **局部变量的引用**，**不会影响到 外部变量的引用**

```python
def demo(num, num_list):

    print("函数内部")

    # 赋值语句
    num = 200
    num_list = [1, 2, 3]

    print(num)
    print(num_list)

    print("函数代码完成")


gl_num = 99
gl_list = [4, 5, 6]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)
    
```

> 问题 2：如果传递的参数是 **可变类型**，在函数内部，使用 **方法** 修改了数据的内容，**同样会影响到外部的数据**

```python
def mutable(num_list):

    # num_list = [1, 2, 3]
    num_list.extend([1, 2, 3])
    
    print(num_list)

gl_list = [6, 7, 8]
mutable(gl_list)
print(gl_list)
```

面试题 —— `+=`

- 在 `python` 中，列表变量调用 `+=` 本质上是在执行列表变量的 `extend` 方法，不会修改变量的引用

```python
def demo(num, num_list):

    print("函数内部代码")

    # num = num + num
    num += num
    # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用
    # 函数执行结束后，外部数据同样会发生变化
    num_list += num_list

    print(num)
    print(num_list)
    print("函数代码完成")


gl_num = 9
gl_list = [1, 2, 3]
demo(gl_num, gl_list)
print(gl_num)
print(gl_list)


```

###### 5.2.4  缺省参数

- 定义函数时，可以给 **某个参数** 指定一个**默认值**，具有默认值的参数就叫做 **缺省参数**
- 调用函数时，如果没有传入 **缺省参数** 的值，则在函数内部使用定义函数时指定的 **参数默认值**
- 函数的缺省参数，**将常见的值设置为参数的缺省值**，从而 **简化函数的调用**
- 例如：对列表排序的方法

```python
gl_num_list = [6, 3, 9]

# 默认就是升序排序，因为这种应用需求更多
gl_num_list.sort()
print(gl_num_list)

# 只有当需要降序排序时，才需要传递 `reverse` 参数
gl_num_list.sort(reverse=True)
print(gl_num_list)

```

1. 指定函数的缺省参数

- 在参数后使用赋值语句，可以指定参数的缺省值

```python
def print_info(name, gender=True):

    gender_text = "男生"
    if not gender:
        gender_text = "女生"

    print("%s 是 %s" % (name, gender_text))

```

**提示**

1. 缺省参数，需要使用 **最常见的值** 作为默认值！
2. 如果一个参数的值 **不能确定**，则不应该设置默认值，具体的数值在调用函数时，由外界传递！

2. 缺省参数的注意事项

1) 缺省参数的定义位置

- **必须保证** **带有默认值的缺省参数** **在参数列表末尾**
- 所以，以下定义是错误的！

```python
def print_info(name, gender=True, title):

```

2) 调用带有多个缺省参数的函数

- 在 **调用函数时**，如果有 **多个缺省参数**，**需要指定参数名**，这样解释器才能够知道参数的对应关系！

```python
def print_info(name, title="", gender=True):
    """

    :param title: 职位
    :param name: 班上同学的姓名
    :param gender: True 男生 False 女生
    """

    gender_text = "男生"

    if not gender:
        gender_text = "女生"

    print("%s%s 是 %s" % (title, name, gender_text))


# 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！
print_info("小明")
print_info("老王", title="班长")
print_info("小美", gender=False)


```

###### 5.2.5  多值参数

1. 定义支持多值参数的函数

- 有时可能需要 **一个函数** 能够处理的参数 **个数** 是不确定的，这个时候，就可以使用 **多值参数**
- `python` 中有 **两种** 多值参数：
  - 参数名前增加 **一个** `*` 可以接收 **元组**
  - 参数名前增加 **两个** `*` 可以接收 **字典**
- 一般在给多值参数命名时，**习惯**使用以下两个名字
  - `*args` —— 存放 **元组** 参数，前面有一个 `*`
  - `**kwargs` —— 存放 **字典** 参数，前面有两个 `*`
- `args` 是 `arguments` 的缩写，有变量的含义
- `kw` 是 `keyword` 的缩写，`kwargs` 可以记忆 **键值对参数**

```python
def demo(num, *args, **kwargs):

    print(num)
    print(args)
    print(kwargs)


demo(1, 2, 3, 4, 5, name="小明", age=18, gender=True)


```

> 提示：**多值参数** 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，**有利于我们能够读懂大牛的代码**



2. 元组和字典的拆包

- 在调用带有多值参数的函数时，如果希望：
  - 将一个 **元组变量**，直接传递给 `args`
  - 将一个 **字典变量**，直接传递给 `kwargs`
- 就可以使用 **拆包**，简化参数的传递，**拆包** 的方式是：
  - 在 **元组变量前**，增加 **一个** `*`
  - 在 **字典变量前**，增加 **两个** `*`

```python
def demo(*args, **kwargs):

    print(args)
    print(kwargs)


# 需要将一个元组变量/字典变量传递给函数对应的参数
gl_nums = (1, 2, 3)
gl_xiaoming = {"name": "小明", "age": 18}

# 会把 num_tuple 和 xiaoming 作为元组传递给 args
# demo(gl_nums, gl_xiaoming)
demo(*gl_nums, **gl_xiaoming)


```

##### 5.3  函数的递归

> 函数调用自身的 **编程技巧** 称为递归

###### 5.3.1 递归函数的特点

**特点**

- **一个函数** **内部** **调用自己**
  - 函数内部可以调用其他函数，当然在函数内部也可以调用自己

**代码特点**

1. 函数内部的 **代码** 是相同的，只是针对 **参数** 不同，**处理的结果不同**
2. 当 **参数满足一个条件** 时，函数不再执行
   - **这个非常重要**，通常被称为递归的出口，否则 **会出现死循环**！

示例代码

```python
def sum_numbers(num):

    print(num)
    
    # 递归的出口很重要，否则会出现死循环
    if num == 1:
        return

    sum_numbers(num - 1)
    
sum_numbers(3)


```



![1558946035224](/1558946035224.png)



递归案例 —— 计算数字累加

**需求**

1. 定义一个函数 `sum_numbers`
2. 能够接收一个 `num` 的整数参数
3. 计算 1 + 2 + ... num 的结果

```python
def sum_numbers(num):

    if num == 1:
        return 1
    
    # 假设 sum_numbers 能够完成 num - 1 的累加
    temp = sum_numbers(num - 1)

    # 函数内部的核心算法就是 两个数字的相加
    return num + temp

print(sum_numbers(2))


```



![1558946069341](/1558946069341.png)



> 提示：递归是一个 **编程技巧**，初次接触递归会感觉有些吃力！在处理 **不确定的循环条件时**，格外的有用，例如：**遍历整个文件目录的结构**



##  面向对象

###  一、 面向对象(OOP)

**面向对象编程** ------ `Object Oriented Programming` 简写 `OOP`

#### 1. 面向对象基本概念 

- 我们之前学习的编程方式就是 **面向过程** 的
- **面相过程** 和 **面相对象**，是两种不同的 **编程方式**

##### 1.1 过程和函数

- **过程** 是早期的一个编程概念
- **过程** 类似于函数，只能执行，但是没有返回值
- **函数** 不仅能执行，还可以返回结果

##### 1.2 面相过程 和 面相对象 基本概念

 1) **面相过程** ------ **怎么做**？ 

1. 把完成某一个需求的 `所有步骤` `从头到尾` 逐步实现
2. 根据开发需求，将某些 **功能独立** 的代码 **封装** 成一个又一个
   **函数**
3. 最后完成的代码，就是顺序地调用 **不同的函数**

**特点**

1. 注重 **步骤与过程**，不注重职责分工
2. 如果需求复杂，代码会变得很复杂
3. **开发复杂项目，没有固定的套路，开发难度很大！**


 2)  **面向对象** ------ **谁来做**？

> 相比较函数，**面向对象** 是 **更大** 的 一个**封装**，根据 **职责** 在
> **一个对象中 封装 多个方法**

1. 在完成某一个需求前，首先确定 **职责** ------ **要做的事情（方法）**
2. 根据 **职责** 确定不同的 **对象**，在 **对象** 内部封装不同的
   **方法**（多个）
3. 最后完成的代码，就是顺序地让 **不同的对象** 调用 **不同的方法**

**特点**

1. 注重 **对象和职责**，不同的对象承担不同的职责
2. 更加适合应对复杂的需求变化，**是专门应对复杂项目开发，提供的固定套路**
3. **需要在面向过程基础上，再学习一些面向对象的语法**

#### 2.  类和对象 

##### 2.1  类和对象的概念

**类** 和 **对象** 是 **面向对象编程的 两个 核心概念**

###### 2.1.1 类 

- **类** 是对一群具有 **相同 特征** 或者 **行为**
  的事物的一个统称，是抽象的，**不能直接使用**
  - **事物的特征** 被称为 **属性**
  - **事物的行为** 被称为 **方法**
- **类** 就相当于制造飞机时的**图纸**，是一个 **模板**，是
  **负责创建对象的**

###### 2.1.2 对象 

- **对象** 是 **由类创建出来的一个具体存在**，可以直接使用
- 由 **哪一个类** 创建出来的 **对象**，就拥有在 **哪一个类**
  中定义的：
  - 属性
  - 方法
- **对象** 就相当于用 **图纸** **制造** 的飞机

> 在程序开发中，应该 **先有类，再有对象**

##### 2.2 类和对象的关系 

- **类是模板**，**对象** 是根据 **类** 这个模板创建出来的，应该
  **先有类，再有对象**
- **类** 只有一个，而 **对象** 可以有很多个
  - **不同的对象** 之间 **属性** 可能会各不相同
- **类** 中定义了什么 **属性和方法**，**对象**
  中就有什么属性和方法，**不可能多，也不可能少**

##### 2.3 类的设计

在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！

在程序开发中，要设计一个类，通常需要满足一下三个要素：

1. **类名** 这类事物的名字，**满足大驼峰命名法**

2. **属性** 这类事物具有什么样的特征

3. **方法** 这类事物具有什么样的行为

   ![1559041509673](/1559041509673.png)

大驼峰命名法

`CapWords`

1. 每一个单词的首字母大写
2. 单词与单词之间没有下划线

###### 2.3.1 类名的确定 

**名词提炼法** 分析 **整个业务流程**，出现的 **名词**，通常就是找到的类

######  2.3.2 属性和方法的确定 

- 对 **对象的特征描述**，通常可以定义成 **属性**
- **对象具有的行为**（动词），通常可以定义成 **方法**

> 提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑

#### 3.  面相对象基础语法

##### 3.1 `dir` 内置函数

- 在 `Python` 中 **对象几乎是无所不在的**，我们之前学习的
  **变量**、**数据**、**函数** 都是对象

在 `Python` 中可以使用以下两个方法验证：

1. 在 **标识符** / **数据** 后输入一个 `.`，然后按下 `TAB`
   键，`iPython` 会提示该对象能够调用的 **方法列表**
2. 使用内置函数 `dir` 传入 **标识符** / **数据**，可以查看对象内的
   **所有属性及方法**

**提示** `__方法名__` 格式的方法是 `Python` 提供的 **内置方法 /
属性**

| 序号 |   方法名   | 类型 |                     作用                     |
| :--: | :--------: | :--: | :------------------------------------------: |
|  01  | `__new__`  | 方法 |      **创建对象**时，会被 **自动** 调用      |
|  02  | `__init__` | 方法 |    **对象被初始化**时，会被 **自动** 调用    |
|  03  | `__del__`  | 方法 | **对象被从内存中销毁**前，会被 **自动** 调用 |
|  04  | `__str__`  | 方法 | 返回**对象的描述信息**，`print` 函数输出使用 |


**提示** 利用好 `dir()` 函数，在学习时很多内容就不需要死记硬背了

##### 3.2 定义简单的类（只包含方法）

> **面向对象** 是 **更大** 的 **封装**，在 **一个类中 封装
> 多个方法**，这样
> **通过这个类创建出来的对象，就可以直接调用这些方法了**！

- 在 `Python` 中要定义一个只包含方法的类，语法格式如下：

```python
class 类名:

    def 方法1(self, 参数列表):
        pass
    
    def 方法2(self, 参数列表):
        pass
```

- **方法** 的定义格式和之前学习过的**函数** 几乎一样
- 区别在于第一个参数必须是 `self`，暂时先记住，稍后介绍 `self`

> 注意：**类名** 的 命名规则 要符合 **大驼峰命名法**

######  3.2.1 创建对象

- 当一个类定义完成之后，要使用这个类来创建对象，语法格式如下：

```python
对象变量 = 类名()
```

######  3.2.2 第一个面向对象程序

**需求**

- **小猫** 爱 **吃** 鱼，**小猫** 要 **喝** 水

**分析**

1. 定义一个猫类 `Cat`

2. 定义两个方法 `eat` 和 `drink`

3. 按照需求 ------ 不需要定义属性

   ![1559041541384](/1559041541384.png)

```python
class Cat:
    """这是一个猫类"""

    def eat(self):
        print("小猫爱吃鱼")

    def drink(self):
        print("小猫在喝水")

tom = Cat()
tom.drink()
tom.eat()
```



![1559041565550](/1559041565550.png)

##### 3.3  引用概念的强调

> 在面向对象开发中，**引用**的概念是同样适用的！

- 在 `Python` 中使用类 **创建对象之后**，`tom` 变量中 仍然记录的是
  **对象在内存中的地址**
- 也就是 `tom` 变量 **引用** 了 **新建的猫对象**
- 使用 `print` 输出 **对象变量**，默认情况下，是能够输出这个变量
  **引用的对象** 是 **由哪一个类创建的对象**，以及
  **在内存中的地址**（**十六进制表示**）

> 提示：在计算机中，通常使用 **十六进制** 表示 **内存地址**
>
> - **十进制** 和 **十六进制**
> 都是用来表达数字的，只是表示的方式不一样
> - **十进制** 和 **十六进制** 的数字之间可以来回转换

- `%d` 可以以 **10 进制** 输出数字
- `%x` 可以以 **16 进制** 输出数字



#####  3.4 初始化方法 

- 当使用 `类名()` 创建对象时，会 **自动** 执行以下操作：
  1. 为对象在内存中 **分配空间** ------ 创建对象
  2. 为对象的属性 **设置初始值** ------ 初始化方法(`init`)
- 这个 **初始化方法** 就是 `__init__` 方法，`__init__`
  是对象的**内置方法**

> `__init__` 方法是 **专门** 用来定义一个类 **具有哪些属性的方法**！

在 `Cat` 中增加 `__init__` 方法，验证该方法在创建对象时会被自动调用

```python
class Cat:
    """这是一个猫类"""

    def __init__(self):
        print("初始化方法")
```

###### 3.4.1 在初始化方法内部定义属性 

- 在 `__init__` 方法内部使用 `self.属性名 = 属性的初始值` 就可以
  **定义属性**
- 定义属性之后，再使用 `Cat` 类创建的对象，都会拥有该属性

```python
class Cat:

    def __init__(self):

        print("这是一个初始化方法")
        
        # 定义用 Cat 类创建的猫对象都有一个 name 的属性
        self.name = "Tom"

    def eat(self):
        print("%s 爱吃鱼" % self.name)

# 使用类名()创建对象的时候，会自动调用初始化方法 __init__
tom = Cat()

tom.eat()
```

######  3.4.2 改造初始化方法 ------ 初始化的同时设置初始值

- 在开发中，如果希望在 **创建对象的同时，就设置对象的属性**，可以对
  `__init__` 方法进行 **改造**
  1. 把希望设置的属性值，定义成 `__init__` 方法的参数
  2. 在方法内部使用 `self.属性 = 形参` 接收外部传递的参数
  3. 在创建对象时，使用 `类名(属性1, 属性2...)` 调用

```python
class Cat:

    def __init__(self, name):
        print("初始化方法 %s" % name)
        self.name = name
    ...
    
tom = Cat("Tom")
...

lazy_cat = Cat("大懒猫")
...
```

###### 3.4.3 内置方法和属性 


| 序号 |  方法名   | 类型 |                     作用                     |
| :--: | :-------: | :--: | :------------------------------------------: |
|  01  | `__del__` | 方法 | **对象被从内存中销毁**前，会被 **自动** 调用 |
|  02  | `__str__` | 方法 | 返回**对象的描述信息**，`print` 函数输出使用 |


######  3.4.4 `__del__` 方法

- 在 `Python` 中
  - 当使用 `类名()` 创建对象时，为对象 **分配完空间**后，**自动**
    调用 `__init__` 方法
  - 当一个 **对象被从内存中销毁** 前，会 **自动** 调用 `__del__`
    方法
- **应用场景**
  - `__init__` 改造初始化方法，可以让创建对象更加灵活
  - `__del__` 如果希望在对象被销毁前，再做一些事情，可以考虑一下
    `__del__` 方法
- **生命周期**
  - 一个对象从调用 `类名()` 创建，生命周期开始
  - 一个对象的 `__del__` 方法一旦被调用，生命周期结束
  - 在对象的生命周期内，可以访问对象属性，或者让对象调用方法
```python
class Cat:

    def __init__(self, new_name):

        self.name = new_name

        print("%s 来了" % self.name)

    def __del__(self):

        print("%s 去了" % self.name)

# tom 是一个全局变量
tom = Cat("Tom")
print(tom.name)

# del 关键字可以删除一个对象
del tom

print("-" * 50)
```

###### 3.4.5  `__str__` 方法

- 在 `Python` 中，使用 `print` 输出
  **对象变量**，默认情况下，会输出这个变量 **引用的对象** 是
  **由哪一个类创建的对象**，以及
  **在内存中的地址**（**十六进制表示**）
- 如果在开发中，希望使用 `print` 输出 **对象变量** 时，能够打印
  **自定义的内容**，就可以利用 `__str__` 这个内置方法了

> 注意：`__str__` 方法必须返回一个字符串

```python
class Cat:

    def __init__(self, new_name):

        self.name = new_name

        print("%s 来了" % self.name)

    def __del__(self):

        print("%s 去了" % self.name)

    def __str__(self):
        return "我是小猫：%s" % self.name

tom = Cat("Tom")
print(tom)
```

####  4. 面向对象三大特性---封装、继承、多态
##### 4.1 封装

1. **封装** 是面向对象编程的一大特点
2. 面向对象编程的 **第一步** ------ 将 **属性** 和 **方法** **封装**
   到一个抽象的 **类** 中
3. **外界** 使用 **类** 创建 **对象**，然后 **让对象调用方法**
4. **对象方法的细节** 都被 **封装** 在 **类的内部**
5. 封装案例：小明爱跑步 

**需求**
1. **小明** **体重** `75.0` 公斤
2. 小明每次 **跑步** 会减肥 `0.5` 公斤
3. 小明每次 **吃东西** 体重增加 `1` 公斤

> 提示：在 **对象的方法内部**，是可以 **直接访问对象的属性** 的！

![1559041607547](/1559041607547.png)

- 代码实现：

```python
class Person:
    """人类"""

    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __str__(self):

        return "我的名字叫 %s 体重 %.2f 公斤" % (self.name, self.weight)

    def run(self):
        """跑步"""

        print("%s 爱跑步，跑步锻炼身体" % self.name)
        self.weight -= 0.5

    def eat(self):
        """吃东西"""

        print("%s 是吃货，吃完这顿再减肥" % self.name)
        self.weight += 1
```

```python
xiaoming = Person("小明", 75)

xiaoming.run()
xiaoming.eat()
xiaoming.eat()

print(xiaoming)
```
###### 4.1.1 面向对象封装案例 进阶


**封装**

1. **封装** 是面向对象编程的一大特点
2. 面向对象编程的 **第一步** ------ 将 **属性** 和 **方法** **封装**
   到一个抽象的 **类** 中
3. **外界** 使用 **类** 创建 **对象**，然后 **让对象调用方法**
4. **对象方法的细节** 都被 **封装** 在 **类的内部**

> 一个对象的 **属性** 可以是 **另外一个类创建的对象**
> 案例：
1. 士兵突击 

**需求**

1. **士兵** **许三多** 有一把 **AK47**
2. **士兵** 可以 **开火**
3. **枪** 能够 **发射** 子弹
4. **枪** 装填 **装填子弹** ------ **增加子弹数量**

![1559041629641](/1559041629641.png)

step1： 开发枪类

**`shoot` 方法需求**

- 1\> 判断是否有子弹，没有子弹无法射击
- 2\> 使用 `print` 提示射击，并且输出子弹数量

```python
class Gun:

    def __init__(self, model):

        # 枪的型号
        self.model = model
        # 子弹数量
        self.bullet_count = 0

    def add_bullet(self, count):

        self.bullet_count += count

    def shoot(self):

        # 判断是否还有子弹
        if self.bullet_count <= 0:
            print("没有子弹了...")

            return

        # 发射一颗子弹
        self.bullet_count -= 1
        
        print("%s 发射子弹[%d]..." % (self.model, self.bullet_count))

# 创建枪对象
ak47 = Gun("ak47")
ak47.add_bullet(50)
ak47.shoot()
```

step2： 开发士兵类

> 假设：每一个新兵 都 **没有枪**

**定义没有初始值的属性**

在定义属性时，如果 **不知道设置什么初始值**，可以设置为 `None`

- `None` **关键字** 表示 **什么都没有**
- 表示一个 **空对象**，**没有方法和属性，是一个特殊的常量**
- 可以将 `None` 赋值给任何一个变量

**`fire` 方法需求**

- 1\> 判断是否有枪，没有枪没法冲锋
- 2\> 喊一声口号
- 3\> 装填子弹
- 4\> 射击
```python
class Soldier:

    def __init__(self, name):

        # 姓名
        self.name = name
        # 枪，士兵初始没有枪 None 关键字表示什么都没有
        self.gun = None

    def fire(self):

        # 1. 判断士兵是否有枪
        if self.gun is None:
            print("[%s] 还没有枪..." % self.name)

            return

        # 2. 高喊口号
        print("冲啊...[%s]" % self.name)

        # 3. 让枪装填子弹
        self.gun.add_bullet(50)

        # 4. 让枪发射子弹
        self.gun.shoot()
```

**小结**

1. 创建了一个 **士兵类**，使用到 `__init__` 内置方法
2. 在定义属性时，如果 **不知道设置什么初始值**，可以设置为 `None`
3. 在 **封装的** 方法内部，还可以让 **自己的**
   **使用其他类创建的对象属性** 调用已经 **封装好的方法**
4. 身份运算符

身份运算符用于 **比较** 两个对象的 **内存地址** 是否一致 ------
**是否是对同一个对象的引用**

- 在 `Python` 中针对 `None` 比较时，建议使用 `is` 判断

| 运算符 |                   描述                    |              实例              |
| :----: | :---------------------------------------: | :----------------------------: |
|   is   |  is 是判断两个标识符是不是引用同一个对象  |  x is y，类似 id(x) == id(y)   |
| is not | is not 是判断两个标识符是不是引用不同对象 | x is not y，类似 id(a)!= id(b) |

 is 与 == 区别：

`is` 用于判断 **两个变量 引用对象是否为同一个**
`==` 用于判断 **引用变量的值** 是否相等

```python
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> b is a 
False
>>> b == a
True
```

#####  4.2  继承 

- 单继承
- 多继承

**面向对象三大特性**

1. **封装** 根据 **职责** 将 **属性** 和 **方法** **封装** 到一个抽象的
   **类** 中
2. **继承** **实现代码的重用**，相同的代码不需要重复的编写
3. **多态**
   不同的对象调用相同的方法，产生不同的执行结果，**增加代码的灵活度** 

######  4.2.1 继承的概念、语法和特点 

**继承的概念**：**子类** 拥有 **父类** 的所有 **方法** 和 **属性**

![1559112970583](/1559112970583.png)


 1) 继承的语法

```python
class 类名(父类名):

    pass
```

- **子类** 继承自 **父类**，可以直接 **享受**
  父类中已经封装好的方法，不需要再次开发
- **子类** 中应该根据 **职责**，封装 **子类特有的** **属性和方法**

 2) 专业术语

- `Dog` 类是 `Animal` 类的**子类**，`Animal` 类是 `Dog`
  类的**父类**，`Dog` 类从 `Animal` 类**继承**
- `Dog` 类是 `Animal` 类的**派生类**，`Animal` 类是 `Dog`
  类的**基类**，`Dog` 类从 `Animal` 类**派生**

 3) 继承的传递性

- `C` 类从 `B` 类继承，`B` 类又从 `A` 类继承
- 那么 `C` 类就具有 `B` 类和 `A` 类的所有属性和方法

**子类** 拥有 **父类** 以及 **父类的父类** 中封装的所有 **属性** 和
**方法**


###### 4.2.2 方法的重写

- **子类** 拥有 **父类** 的所有 **方法** 和 **属性**
- **子类** 继承自 **父类**，可以直接 **享受**
  父类中已经封装好的方法，不需要再次开发

**应用场景**

- 当 **父类** 的方法实现不能满足子类需求时，可以对方法进行
  **重写(override)**
  
  ![1559113031003](/1559113031003.png)

**重写** 父类方法有两种情况：

1. **覆盖** 父类的方法
2. 对父类方法进行 **扩展**

 1) 覆盖父类的方法 

- 如果在开发中，**父类的方法实现** 和 **子类的方法实现**，**完全不同**
- 就可以使用 **覆盖** 的方式，**在子类中** **重新编写** 父类的方法实现

> 具体的实现方式，就相当于在 **子类中** 定义了一个
> **和父类同名的方法并且实现**

重写之后，在运行时，**只会调用** 子类中重写的方法，而不再会调用
**父类封装的方法**

 2) 对父类方法进行 **扩展** 

- 如果在开发中，**子类的方法实现** 中 **包含** **父类的方法实现**
  - **父类原本封装的方法实现** 是 **子类方法的一部分**
- 就可以使用 **扩展** 的方式
  1. **在子类中** **重写** 父类的方法
  2. 在需要的位置使用 `super().父类方法` 来调用父类方法的执行
  3. 代码其他的位置针对子类的需求，编写 **子类特有的代码实现**

 3） 关于 `super`

- 在 `Python` 中 `super` 是一个 **特殊的类**
- `super()` 就是使用 `super` 类创建出来的对象
- **最常** 使用的场景就是在 **重写父类方法时**，调用
  **在父类中封装的方法实现**

  4）调用父类方法的另外一种方式

> 在 `Python 2.x` 时，如果需要调用父类的方法，还可以使用以下方式：

```python
父类名.方法(self)
```

- 这种方式，目前在 `Python 3.x` 还支持这种方式
- 这种方法 **不推荐使用**，因为一旦 **父类发生变化**，方法调用位置的
  **类名** 同样需要修改

**提示**

- 在开发时，`父类名` 和 `super()` 两种方式不要混用
- 如果使用 **当前子类名** 调用方法，会形成递归调用，**出现死循环**


 ######  4.2.3 多继承

**概念**

- **子类** 可以拥有 **多个父类**，并且具有 **所有父类** 的 **属性** 和
  **方法**
- 例如：**孩子** 会继承自己 **父亲** 和 **母亲** 的 **特性**

**语法**

```python
class 子类名(父类名1, 父类名2...)
    pass
```

 多继承的使用注意事项

**问题的提出**

- 如果 **不同的父类** 中存在 **同名的方法**，**子类对象**
  在调用方法时，会调用 **哪一个父类中**的方法呢？

> 提示：**开发时，应该尽量避免这种容易产生混淆的情况！** ------ 如果
> **父类之间** 存在 **同名的属性或者方法**，应该 **尽量避免** 使用多继承
>
> ![1559113072952](/1559113072952.png)


 Python 中的 MRO ------ 方法搜索顺序

- `Python` 中针对 **类** 提供了一个 **内置属性** `__mro__` 可以查看
  **方法** 搜索顺序
- MRO 是 `method resolution order`，主要用于 **在多继承时判断
  方法、属性 的调用 路径**

```python
print(C.__mro__)
```

**输出结果**

```python
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```

- 在搜索方法时，是按照 `__mro__` 的输出结果 **从左至右** 的顺序查找的
- 如果在当前类中 **找到方法，就直接执行，不再搜索**
- 如果 **没有找到，就查找下一个类**
  中是否有对应的方法，**如果找到，就直接执行，不再搜索**
- 如果找到最后一个类，还没有找到方法，程序报错

###### 4.2.4 新式类与旧式（经典）类

> `object` 是 `Python` 为所有对象提供的
> **基类**，提供有一些内置的属性和方法，可以使用 `dir` 函数查看

- **新式类**：以 `object` 为基类的类，**推荐使用**
- **经典类**：不以 `object` 为基类的类，**不推荐使用**
- 在 `Python 3.x` 中定义类时，如果没有指定父类，会 **默认使用**
  `object` 作为该类的 **基类** ------ `Python 3.x` 中定义的类都是
  **新式类**
- 在 `Python 2.x` 中定义类时，如果没有指定父类，则不会以 `object` 作为
  **基类**

> **新式类** 和 **经典类** 在多继承时 ------ **会影响到方法的搜索顺序**

为了保证编写的代码能够同时在 `Python 2.x` 和 `Python 3.x` 运行！\
今后在定义类时，**如果没有父类，建议统一继承自 `object`**

```python
class 类名(object):
    pass
```


#####  4.3 多态 

**面向对象三大特性**

1. **封装** 根据 **职责** 将 **属性** 和 **方法** **封装** 到一个抽象的
   **类** 中

   - 定义类的准则

2. **继承** **实现代码的重用**，相同的代码不需要重复的编写

   - 设计类的技巧
   - 子类针对自己特有的需求，编写特定的代码

3. **多态** 不同的 **子类对象** 调用相同的
   **父类方法**，产生不同的执行结果

   - **多态** 可以 **增加代码的灵活度**
   - 以 **继承** 和 **重写父类方法** 为前提
   - 是调用方法的技巧，**不会影响到类的内部设计**
   - ![1559113111782](/1559113111782.png)


######  4.3.1多态案例演练 

**需求**

1. 在 `Dog` 类中封装方法 `game`
   - 普通狗只是简单的玩耍
2. 定义 `XiaoTianDog` 继承自 `Dog`，并且重写 `game` 方法
   - 哮天犬需要在天上玩耍
3. 定义 `Person` 类，并且封装一个 **和狗玩** 的方法
   - 在方法内部，直接让 **狗对象** 调用 `game` 方法

![1559113130431](/1559113130431.png)

**案例小结**

- `Person` 类中只需要让 **狗对象** 调用 `game` 方法，而不关心具体是
  **什么狗**
  - `game` 方法是在 `Dog` 父类中定义的
- 在程序执行时，传入不同的 **狗对象** 实参，就会产生不同的执行效果

> **多态**
> 更容易编写出出通用的代码，做出通用的编程，以适应需求的不断变化！

```python
class Dog(object):

    def __init__(self, name):
        self.name = name

    def game(self):
        print("%s 蹦蹦跳跳的玩耍..." % self.name)
```

```python
class XiaoTianDog(Dog):

    def game(self):
        print("%s 飞到天上去玩耍..." % self.name)
```

```python
class Person(object):

    def __init__(self, name):
        self.name = name

    def game_with_dog(self, dog):

        print("%s 和 %s 快乐的玩耍..." % (self.name, dog.name))

        # 让狗玩耍
        dog.game()
```

```python
# 1. 创建一个狗对象
# wangcai = Dog("旺财")
wangcai = XiaoTianDog("飞天旺财")

# 2. 创建一个小明对象
xiaoming = Person("小明")

# 3. 让小明调用和狗玩的方法
xiaoming.game_with_dog(wangcai)
```



####  5、属性和方法


#####  5.1  私有属性和私有方法

######  5.1.1 应用场景及定义方式 

**应用场景**

- 在实际开发中，**对象** 的 **某些属性或方法** 可能只希望
  **在对象的内部被使用**，而 **不希望在外部被访问到**
- **私有属性** 就是 **对象** 不希望公开的 **属性**
- **私有方法** 就是 **对象** 不希望公开的 **方法**

**定义方式**

- 在 **定义属性或方法时**，在 **属性名或者方法名前** 增加
  **两个下划线**，定义的就是 **私有** 属性或方法
  
  ![1559113819466](/1559113819466.png)


```python
class Women:

    def __init__(self, name):

        self.name = name
        # 不要问女生的年龄
        self.__age = 18

    def __secret(self):
        print("我的年龄是 %d" % self.__age)
```

```python
xiaofang = Women("小芳")
# 私有属性，外部不能直接访问
# print(xiaofang.__age)

# 私有方法，外部不能直接调用
# xiaofang.__secret()
```

###### 5.1.2 伪私有属性和私有方法

> 提示：在日常开发中，**不要使用这种方式**，**访问对象的 私有属性 或
> 私有方法**

`Python` 中，并没有 **真正意义** 的 **私有**

- 在给 **属性**、**方法** 命名时，实际是对 **名称**
  做了一些特殊处理，使得外界无法访问到
- **处理方式**：在 **名称** 前面加上 `_类名` =\> `_类名__名称`

```python
# 私有属性，外部不能直接访问到
print(xiaofang._Women__age)

# 私有方法，外部不能直接调用
xiaofang._Women__secret()
```
##### 5.2 类属性和类方法 


######  5.2.1 术语 ------ 实例 

1. 使用面相对象开发，**第 1 步** 是设计 **类**
2. 使用 **类名()** 创建对象，**创建对象** 的动作有两步：
   - 1\) 在内存中为对象 **分配空间**
   - 2\) 调用初始化方法 `__init__` 为 **对象初始化**
3. 对象创建后，**内存** 中就有了一个对象的 **实实在在** 的存在 ------
   **实例**

![1559113862772](/1559113862772.png)

因此，通常也会把：

1. 创建出来的 **对象** 叫做 **类** 的 **实例**
2. 创建对象的 **动作** 叫做 **实例化**
3. **对象的属性** 叫做 **实例属性**
4. **对象调用的方法** 叫做 **实例方法**

在程序执行时：

1. 对象各自拥有自己的 **实例属性**
2. 调用对象方法，可以通过 `self.`
   - 访问自己的属性
   - 调用自己的方法

**结论**

- **每一个对象** 都有自己 **独立的内存空间**，**保存各自不同的属性**
- **多个对象的方法**，**在内存中只有一份**，在调用方法时，**需要把对象的引用**
  传递到方法内部

 ** 类是一个特殊的对象 **

> `Python` 中 **一切皆对象**：
>
> - `class AAA:` 定义的类属于 **类对象**
> - `obj1 = AAA()` 属于 **实例对象**

- 在程序运行时，**类** 同样 **会被加载到内存**
- 在 `Python` 中，**类** 是一个特殊的对象 ------ **类对象**
- 在程序运行时，**类对象** 在内存中 **只有一份**，使用 **一个类**
  可以创建出 **很多个对象实例**
- 除了封装 **实例** 的 **属性** 和 **方法**外，**类对象**
  还可以拥有自己的 **属性** 和 **方法**
  1. **类属性**
  2. **类方法**
- 通过 **类名.** 的方式可以 **访问类的属性** 或者 **调用类的方法**

![1559113894457](/1559113894457.png)

###### 5.2.2 类属性和实例属性 

1.  概念和使用

- **类属性** 就是给 **类对象** 中定义的 **属性**
- 通常用来记录 **与这个类相关** 的特征
- **类属性** **不会用于**记录 **具体对象的特征**

**示例需求**

- 定义一个 **工具类**

- 每件工具都有自己的 `name`

- **需求** ------ 知道使用这个类，创建了多少个工具对象？

  ![1559114245430](/1559114245430.png)

```python
class Tool(object):

    # 使用赋值语句，定义类属性，记录创建工具对象的总数
    count = 0

    def __init__(self, name):
        self.name = name

        # 针对类属性做一个计数+1
        Tool.count += 1
```

```python
# 创建工具对象
tool1 = Tool("斧头")
tool2 = Tool("榔头")
tool3 = Tool("铁锹")

# 知道使用 Tool 类到底创建了多少个对象?
print("现在创建了 %d 个工具" % Tool.count)
```

2. 属性的获取机制

- 在 `Python` 中 **属性的获取** 存在一个 **向上查找机制**

  ![1559114270905](/1559114270905.png)

- 因此，要访问类属性有两种方式：
  1. **类名.类属性**
  2. **对象.类属性** （不推荐）

**注意**

- 如果使用 `对象.类属性 = 值` 赋值语句，只会
  **给对象添加一个属性**，而不会影响到 **类属性的值**

3. 类方法和静态方法

------

######  5.2.3 类方法 

- **类属性** 就是针对 **类对象** 定义的属性
  - 使用 **赋值语句** 在 `class` 关键字下方可以定义 **类属性**
  - **类属性** 用于记录 **与这个类相关** 的特征
- **类方法** 就是针对 **类对象** 定义的方法
  - 在 **类方法** 内部可以直接访问 **类属性** 或者调用其他的
    **类方法**

**语法如下**

```python
@classmethod
def 类方法名(cls):
    pass
```

- 类方法需要用 **修饰器** `@classmethod`
  来标识，**告诉解释器这是一个类方法**
- 类方法的 **第一个参数** 应该是 `cls`
  - 由 **哪一个类** 调用的方法，方法内的 `cls` 就是
    **哪一个类的引用**
  - 这个参数和 **实例方法** 的第一个参数是 `self` 类似
  - **提示** 使用其他名称也可以，不过习惯使用 `cls`
- 通过 **类名.** 调用 **类方法**，**调用方法时**，不需要传递 `cls`
  参数
- **在方法内部**
  - 可以通过 `cls.` **访问类的属性**
  - 也可以通过 `cls.` **调用其他的类方法**

**示例需求**

- 定义一个 **工具类**

- 每件工具都有自己的 `name`

- **需求** ------ 在 **类** 封装一个 `show_tool_count`
  的类方法，输出使用当前这个类，创建的对象个数
  
  ![1559114298822](/1559114298822.png)

```python
@classmethod
def show_tool_count(cls):
    """显示工具对象的总数"""
    print("工具对象的总数 %d" % cls.count)
```

> 在类方法内部，可以直接使用 `cls` 访问 **类属性** 或者 **调用类方法**

###### 5.2.4 静态方法 

- 在开发时，如果需要在 **类** 中封装一个方法，这个方法：
  - 既 **不需要** 访问 **实例属性** 或者调用 **实例方法**
  - 也 **不需要** 访问 **类属性** 或者调用 **类方法**
- 这个时候，可以把这个方法封装成一个 **静态方法**

**语法如下**

```python
@staticmethod
def 静态方法名():
    pass
```
- **静态方法** 需要用 **修饰器** `@staticmethod`
  来标识，**告诉解释器这是一个静态方法**
- 通过 **类名.** 调用 **静态方法**

```python
class Dog(object):
    
    # 狗对象计数
    dog_count = 0
    
    @staticmethod
    def run():
        
        # 不需要访问实例属性也不需要访问类属性的方法
        print("狗在跑...")

    def __init__(self, name):
        self.name = name
```

######  5.2.5 方法综合案例 

**需求**

1. 设计一个 `Game` 类
2. 属性：
   - 定义一个 **类属性** `top_score` 记录游戏的 **历史最高分**
   - 定义一个 **实例属性** `player_name` 记录 **当前游戏的玩家姓名**
3. 方法：
   - **静态方法** `show_help` 显示游戏帮助信息
   - **类方法** `show_top_score` 显示历史最高分
   - **实例方法** `start_game` 开始当前玩家的游戏
4. 主程序步骤
   - 1\) 查看帮助信息
   - 2\) 查看历史最高分
   - 3\) 创建游戏对象，开始游戏

![1559114329333](/1559114329333.png)

案例小结 

1. **实例方法** ------ 方法内部需要访问 **实例属性**
   - **实例方法** 内部可以使用 **类名.** 访问类属性
2. **类方法** ------ 方法内部 **只** 需要访问 **类属性**
3. **静态方法** ------ 方法内部，不需要访问 **实例属性** 和 **类属性**


```python
class Game(object):

    # 游戏最高分，类属性
    top_score = 0

    @staticmethod
    def show_help():
        print("帮助信息：让僵尸走进房间")
        
    @classmethod
    def show_top_score(cls):
        print("游戏最高分是 %d" % cls.top_score)

    def __init__(self, player_name):
        self.player_name = player_name

    def start_game(self):
        print("[%s] 开始游戏..." % self.player_name)
        
        # 使用类名.修改历史最高分
        Game.top_score = 999

# 1. 查看游戏帮助
Game.show_help()

# 2. 查看游戏最高分
Game.show_top_score()

# 3. 创建游戏对象，开始游戏
game = Game("小明")

game.start_game()

# 4. 游戏结束，查看游戏最高分
Game.show_top_score()
```



####  6、模块和包、文件


##### 6.1 模块

> **模块是 Python 程序架构的一个核心概念**

- 每一个以扩展名 `py` 结尾的 `Python` 源代码文件都是一个 **模块**
- **模块名** 同样也是一个 **标识符**，需要符合标识符的命名规则
- 在模块中定义的 **全局变量** 、**函数**、**类**
  都是提供给外界直接使用的 **工具**
- **模块** 就好比是 **工具包**，要想使用这个工具包中的工具，就需要先
  **导入** 这个模块

###### 6.1.1 模块的两种导入方式 

 1）import 导入

> 提示：在导入模块时，每个导入应该独占一行

```python
import 模块名1
import 模块名2 
```

- **导入之后**
  - 通过 `模块名.` 使用 **模块提供的工具** ------
    **全局变量**、**函数**、**类**

使用 `as` 指定模块的别名 

> **如果模块的名字太长**，可以使用 `as`
> 指定模块的名称，以方便在代码中的使用

```
import 模块名1 as 模块别名
```

> 注意：**模块别名** 应该符合 **大驼峰命名法**

 2）from\...import 导入

- 如果希望 **从某一个模块** 中，导入 **部分** 工具，就可以使用
  `from ... import` 的方式
- `import 模块名` 是 **一次性** 把模块中
  **所有工具全部导入**，并且通过 **模块名/别名** 访问

```
# 从 模块 导入 某一个工具
from 模块名1 import 工具名
```

- 导入之后
  - **不需要** 通过 `模块名.`
  - 可以直接使用 **模块提供的工具** ------
    **全局变量**、**函数**、**类**

**注意**

> 如果 **两个模块**，存在 **同名的函数**，那么 **后导入模块的函数**，会
> **覆盖掉先导入的函数**

- 开发时 `import` 代码应该统一写在 **代码的顶部**，更容易及时发现冲突
- 一旦发现冲突，可以使用 `as` 关键字 **给其中一个工具起一个别名**

```python
# 从 模块 导入 所有工具
from 模块名1 import *
```

**注意**

> 这种方式不推荐使用，因为函数重名并没有任何的提示，出现问题不好排查

######  6.1.2 模块的搜索顺序\[扩展\] 

`Python` 的解释器在 **导入模块** 时，会：

1. 搜索 **当前目录** 指定模块名的文件，**如果有就直接导入**
2. 如果没有，再搜索 **系统目录**

> 在开发时，给文件起名，不要和 **系统的模块文件** **重名**

`Python` 中每一个模块都有一个内置属性 `__file__` 可以 **查看模块** 的
**完整路径**

**示例**

```python
import random

# 生成一个 0～10 的数字
rand = random.randint(0, 10)

print(rand)
```

> 注意：如果当前目录下，存在一个 `random.py`
> 的文件，程序就无法正常执行了！

- 这个时候，`Python` 的解释器会 **加载当前目录** 下的 `random.py`
  而不会加载 **系统的** `random` 模块

###### 6.1.3 原则 ------ 每一个文件都应该是可以被导入的

- 一个 **独立的 `Python` 文件** 就是一个 **模块**
- 在导入文件时，文件中 **所有没有任何缩进的代码** 都会被执行一遍！

**实际开发场景**

- 在实际开发中，每一个模块都是独立开发的，大多都有专人负责
- **开发人员** 通常会在 **模块下方** **增加一些测试代码**
  - 仅在模块内使用，而被导入到其他文件中不需要执行

 `__name__` 属性 

> - `__name__` 属性可以做到，测试模块的代码
> **只在测试情况下被运行**，而在 **被导入时不会被执行**！

- `__name__` 是 `Python` 的一个内置属性，记录着一个 **字符串**
- 如果 **是被其他文件导入的**，`__name__` 就是 **模块名**
- 如果 **是当前执行的程序** `__name__` 是 **`__main__`**

**在很多 `Python` 文件中都会看到以下格式的代码**：

```python
# 导入模块
# 定义全局变量
# 定义类
# 定义函数

# 在代码的最下方
def main():
    # ...
    pass

# 根据 __name__ 判断是否执行下方代码
if __name__ == "__main__":
    main()
```

##### 6.2 包（Package）

- **包** 是一个 **包含多个模块** 的 **特殊目录**
- 目录下有一个 **特殊的文件** `__init__.py`
- 包名的 **命名方式** 和变量名一致，**小写字母** + `_`

**好处**

- 使用 `import 包名` 可以一次性导入 **包** 中 **所有的模块**


 `__init__.py` 

- 要在外界使用 **包** 中的模块，需要在 `__init__.py` 中指定
  **对外界提供的模块列表**

```
# 从 当前目录 导入 模块列表
from . import send_message
from . import receive_message
```

##### 6.3 发布模块

- 如果希望自己开发的模块，**分享** 给其他人，可以按照以下步骤操作

######  6.3.1 制作发布压缩包步骤 

1) 创建 setup.py 

- `setup.py` 的文件

```python
from distutils.core import setup

setup(name="hm_message",  # 包名
      version="1.0",  # 版本
      description="itheima's 发送和接收消息模块",  # 描述信息
      long_description="完整的发送和接收消息模块",  # 完整描述信息
      author="itheima",  # 作者
      author_email="itheima@itheima.com",  # 作者邮箱
      url="www.itheima.com",  # 主页
      py_modules=["hm_message.send_message",
                  "hm_message.receive_message"])

```

有关字典参数的详细信息，可以参阅官方网站：

<https://docs.python.org/2/distutils/apiref.html>

2) 构建模块

```python
$ python3 setup.py build

```

 3) 生成发布压缩包 {#toc_20}

```python
$ python3 setup.py sdist

```

> 注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！

######  6.3.2 安装模块 

```python
$ tar -zxvf hm_message-1.0.tar.gz 

$ sudo python3 setup.py install

```

**卸载模块**

直接从安装目录下，把安装模块的 **目录** 删除就可以

```
$ cd /usr/local/lib/python3.5/dist-packages/
$ sudo rm -r hm_message*

```

######  6.3.3 `pip` 安装第三方模块

- **第三方模块** 通常是指由 **知名的第三方团队** **开发的** 并且被
  **程序员广泛使用** 的 `Python` 包 / 模块
  - 例如 `pygame` 就是一套非常成熟的 **游戏开发模块**
- `pip` 是一个现代的，通用的 `Python` 包管理工具
- 提供了对 `Python` 包的查找、下载、安装、卸载等功能

安装和卸载命令如下：

```
# 将模块安装到 Python 2.x 环境
$ sudo pip install pygame
$ sudo pip uninstall pygame

# 将模块安装到 Python 3.x 环境
$ sudo pip3 install pygame
$ sudo pip3 uninstall pygame

```

在 `Mac` 下安装 `iPython` 

```
$ sudo pip install ipython

```

在 `Linux` 下安装 `iPython` 

```
$ sudo apt install ipython
$ sudo apt install ipython3

```


#####  6.4 文件 

###### 6.4.1 文件的概念和作用

- 计算机的 **文件**，就是存储在某种 **长期储存设备** 上的一段 **数据**
- 长期存储设备包括：硬盘、U 盘、移动硬盘、光盘\...

**文件的作用**

将数据长期保存下来，在需要的时候使用

###### 6.4.2 文件的存储方式

- 在计算机中，文件是以 **二进制** 的方式保存在磁盘上的

 文本文件和二进制文件

- 文本文件
  - 可以使用 **文本编辑软件** 查看
  - 本质上还是二进制文件
  - 例如：python 的源程序
- 二进制文件
  - 保存的内容 不是给人直接阅读的，而是 **提供给其他软件使用的**
  - 例如：图片文件、音频文件、视频文件等等
  - 二进制文件不能使用 **文本编辑软件** 查看

######  6.4.3 文件的基本操作 

在 **计算机** 中要操作文件的套路非常固定，一共包含**三个步骤**：

1. 打开文件
2. 读、写文件
   - **读** 将文件内容读入内存
   - **写** 将内存内容写入文件
3. 关闭文件

 操作文件的函数/方法 

- 在 `Python` 中要操作文件需要记住 1 个函数和 3 个方法

| 序号 |      | 函数/方法 |      |              说明              |
| :--: | ---- | :-------: | ---- | :----------------------------: |
|  01  |      |   open    |      | 打开文件，并且返回文件操作对象 |
|  02  |      |   read    |      |      将文件内容读取到内存      |
|  03  |      |   write   |      |       将指定内容写入文件       |
|  04  |      |   close   |      |            关闭文件            |

- `open` 函数负责打开文件，并且返回文件对象

- `read`/`write`/`close` 三个方法都需要通过 **文件对象** 来调用

 read 方法 ------ 读取文件 

- `open` 函数的第一个参数是要打开的文件名（文件名区分大小写）
  - 如果文件 **存在**，返回 **文件操作对象**
  - 如果文件 **不存在**，会 **抛出异常**
- `read` 方法可以一次性 **读入** 并 **返回** 文件的 **所有内容**
- `close` 方法负责 **关闭文件**
  - 如果
    **忘记关闭文件**，**会造成系统资源消耗，而且会影响到后续对文件的访问**
- **注意**：`read` 方法执行后，会把 **文件指针** 移动到 **文件的末尾**
- 
```
# 1. 打开 - 文件名需要注意大小写
file = open("README")

# 2. 读取
text = file.read()
print(text)

# 3. 关闭
file.close()
```

**提示**

- 在开发中，通常会先编写 **打开** 和 **关闭**
  的代码，再编写中间针对文件的 **读/写** 操作！

######  6.4.4 文件指针

- **文件指针** 标记 **从哪个位置开始读取数据**
- **第一次打开** 文件时，通常 **文件指针会指向文件的开始位置**
- 当执行了 `read` 方法后，**文件指针** 会移动到 **读取内容的末尾**
  - 默认情况下会移动到 **文件末尾**

**思考**

- 如果执行了一次 `read` 方法，读取了所有内容，那么再次调用 `read`
  方法，还能够获得到内容吗？

**答案**

- 不能
- 第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容

 打开文件的方式

- `open` 函数默认以 **只读方式** 打开文件，并且返回文件对象

语法如下：

```
f = open("文件名", "访问方式")
```

| 访问方式 |      |                             说明                             |
| :------: | ---- | :----------------------------------------------------------: |
|    r     |      | 以**只读**方式打开文件。文件的指针将会放在文件的开头，这是**默认模式**。如果文件不存在，抛出异常 |
|    w     |      | 以**只写**方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 |
|    a     |      | 以**追加**方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 |
|    r+    |      | 以**读写**方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 |
|    w+    |      | 以**读写**方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 |
|    a+    |      | 以**读写**方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 |


**提示**

- 频繁的移动文件指针，**会影响文件的读写效率**，开发中更多的时候会以
  **只读**、**只写** 的方式来操作文件

**写入文件示例**

```python
# 打开文件
f = open("README", "w")

f.write("hello python！\n")
f.write("今天天气真好")

# 关闭文件
f.close()
```

 按行读取文件内容

- `read` 方法默认会把文件的 **所有内容** **一次性读取到内存**
- 如果文件太大，对内存的占用会非常严重

 `readline` 方法

- `readline` 方法可以一次读取一行内容
- 方法执行后，会把 **文件指针** 移动到下一行，准备再次读取

**读取大文件的正确姿势**

```python
# 打开文件
file = open("README")

while True:
    # 读取一行内容
    text = file.readline()

    # 判断是否读到内容
    if not text:
        break

    # 每读取一行的末尾已经有了一个 `\n`
    print(text, end="")

# 关闭文件
file.close()
```


 小文件复制 

- 打开一个已有文件，读取完整内容，并写入到另外一个文件

```python
# 1. 打开文件
file_read = open("README")
file_write = open("README[复件]", "w")

# 2. 读取并写入文件
text = file_read.read()
file_write.write(text)

# 3. 关闭文件
file_read.close()
file_write.close()
```

 大文件复制

- 打开一个已有文件，逐行读取内容，并顺序写入到另外一个文件

```python
# 1. 打开文件
file_read = open("README")
file_write = open("README[复件]", "w")

# 2. 读取并写入文件
while True:
    # 每次读取一行
    text = file_read.readline()

    # 判断是否读取到内容
    if not text:
        break

    file_write.write(text)

# 3. 关闭文件
file_read.close()
file_write.close()
```

3. 文件/目录的常用管理操作 

- 在 **终端** / **文件浏览器**、 中可以执行常规的 **文件** / **目录**
  管理操作，例如：
  - 创建、重命名、删除、改变路径、查看目录内容、......
- 在 `Python` 中，如果希望通过程序实现上述功能，需要导入 `os` 模块

 文件操作

| 序号 |      | 方法名 |      |    说明    |      |               示例                |
| :--: | ---- | :----: | ---- | :--------: | ---- | :-------------------------------: |
|  01  |      | rename |      | 重命名文件 |      | `os.rename(源文件名, 目标文件名)` |
|  02  |      | remove |      |  删除文件  |      |        `os.remove(文件名)`        |

 目录操作 
| 序号 |      |   方法名   |      |      说明      |      |           示例            |
| :--: | ---- | :--------: | ---- | :------------: | ---- | :-----------------------: |
|  01  |      |  listdir   |      |    目录列表    |      |   `os.listdir(目录名)`    |
|  02  |      |   mkdir    |      |    创建目录    |      |    `os.mkdir(目录名)`     |
|  03  |      |   rmdir    |      |    删除目录    |      |    `os.rmdir(目录名)`     |
|  04  |      |   getcwd   |      |  获取当前目录  |      |       `os.getcwd()`       |
|  05  |      |   chdir    |      |  修改工作目录  |      |   `os.chdir(目标目录)`    |
|  06  |      | path.isdir |      | 判断是否是文件 |      | `os.path.isdir(文件路径)` |

> 提示：文件或者目录操作都支持 **相对路径** 和 **绝对路径**

4. 文本文件的编码格式

- 文本文件存储的内容是基于 **字符编码** 的文件，常见的编码有 `ASCII`
  编码，`UNICODE` 编码等

> Python 2.x 默认使用 `ASCII` 编码格式\
> Python 3.x 默认使用 `UTF-8` 编码格式

 `ASCII` 编码

- 计算机中只有 `256` 个 `ASCII` 字符
- 一个 `ASCII` 在内存中占用 **1 个字节** 的空间
  - `8` 个 `0/1` 的排列组合方式一共有 `256` 种，也就是 `2 ** 8`

 `UTF-8` 编码格式 

- 计算机中使用 **1\~6 个字节** 来表示一个 `UTF-8` 字符，涵盖了
  **地球上几乎所有地区的文字**
- 大多数汉字会使用 **3 个字节** 表示
- `UTF-8` 是 `UNICODE` 编码的一种编码格式

 Ptyhon 2.x 中如何使用中文

> Python 2.x 默认使用 `ASCII` 编码格式\
> Python 3.x 默认使用 `UTF-8` 编码格式

- 在 Python 2.x 文件的 **第一行** 增加以下代码，解释器会以 `utf-8`
  编码来处理 python 文件

```
# *-* coding:utf8 *-*
```

> 这方式是官方推荐使用的！

- 也可以使用

```
# coding=utf8
```

 unicode 字符串

- 在 `Python 2.x` 中，即使指定了文件使用 `UTF-8`
  的编码格式，但是在遍历字符串时，仍然会 **以字节为单位遍历** 字符串
- 要能够 **正确的遍历字符串**，在定义字符串时，需要
  **在字符串的引号前**，增加一个小写字母 `u`，告诉解释器这是一个
  `unicode` 字符串（使用 `UTF-8` 编码格式的字符串）

```
# *-* coding:utf8 *-*

# 在字符串前，增加一个 `u` 表示这个字符串是一个 utf8 字符串
hello_str = u"你好世界"

print(hello_str)

for c in hello_str:
    print(c)
```

####  7、单例、异常以及eval函数


#####  7.1 单例 

###### 7.1.1 单例设计模式

- 设计模式
  - **设计模式** 是
    **前人工作的总结和提炼**，通常，被人们广泛流传的设计模式都是针对
    **某一特定问题** 的成熟的解决方案
  - 使用 **设计模式**
    是为了可重用代码、让代码更容易被他人理解、保证代码可靠性
- 单例设计模式
  - **目的** ------ 让 **类** 创建的对象，在系统中 **只有**
    **唯一的一个实例**
  - 每一次执行 `类名()` 返回的对象，**内存地址是相同的**


######  7.1.2  `__new__` 方法 

- 使用 **类名()** 创建对象时，`Python` 的解释器 **首先** 会 调用
  `__new__` 方法为对象 **分配空间**
- `__new__` 是一个 由 `object` 基类提供的
  **内置的静态方法**，主要作用有两个：
  - 1\) 在内存中为对象 **分配空间**
  - 2\) **返回** 对象的引用
- `Python` 的解释器获得对象的 **引用** 后，将引用作为
  **第一个参数**，传递给 `__init__` 方法

> 重写 `__new__` 方法 的代码非常固定！

- 重写 `__new__` 方法 **一定要** `return super().__new__(cls)`
- 否则 Python 的解释器 **得不到** 分配了空间的
  **对象引用**，**就不会调用对象的初始化方法**
- 注意：`__new__` 是一个静态方法，在调用时需要 **主动传递** `cls` 参数


**示例代码**

```python
class MusicPlayer(object):

    def __new__(cls, *args, **kwargs):
        # 如果不返回任何结果，
        return super().__new__(cls)

    def __init__(self):
        print("初始化音乐播放对象")

player = MusicPlayer()

print(player)
```

######  7.1.3  Python 中的单例  
- **单例** ------ 让 **类** 创建的对象，在系统中 **只有**
  **唯一的一个实例**
  1. 定义一个 **类属性**，初始值是 `None`，用于记录
     **单例对象的引用**
  2. 重写 `__new__` 方法
  3. 如果 **类属性**
     `is None`，调用父类方法分配空间，并在类属性中记录结果
  4. 返回 **类属性** 中记录的 **对象引用**

```python
class MusicPlayer(object):

    # 定义类属性记录单例对象引用
    instance = None

    def __new__(cls, *args, **kwargs):

        # 1. 判断类属性是否已经被赋值
        if cls.instance is None:
            cls.instance = super().__new__(cls)

        # 2. 返回类属性的单例引用
        return cls.instance
```

 只执行一次初始化工作 

- 在每次使用 `类名()` 创建对象时，`Python`
  的解释器都会自动调用两个方法：
  - `__new__` 分配空间
  - `__init__` 对象初始化
- 在上一小节对 `__new__` 方法改造之后，每次都会得到
  **第一次被创建对象的引用**
- 但是：**初始化方法还会被再次调用**

**需求**

- 让 **初始化动作** 只被 **执行一次**

**解决办法**

1. 定义一个类属性 `init_flag` 标记是否 **执行过初始化动作**，初始值为
   `False`
2. 在 `__init__` 方法中，判断 `init_flag`，如果为 `False`
   就执行初始化动作
3. 然后将 `init_flag` 设置为 `True`
4. 这样，再次 **自动** 调用 `__init__`
   方法时，**初始化动作就不会被再次执行** 了

```python
class MusicPlayer(object):

    # 记录第一个被创建对象的引用
    instance = None
    # 记录是否执行过初始化动作
    init_flag = False

    def __new__(cls, *args, **kwargs):

        # 1. 判断类属性是否是空对象
        if cls.instance is None:
            # 2. 调用父类的方法，为第一个对象分配空间
            cls.instance = super().__new__(cls)

        # 3. 返回类属性保存的对象引用
        return cls.instance

    def __init__(self):

        if not MusicPlayer.init_flag:
            print("初始化音乐播放器")

            MusicPlayer.init_flag = True
```

```python
#测试： 创建多个对象
player1 = MusicPlayer()
print(player1)

player2 = MusicPlayer()
print(player2)
```

##### 7.2 异常 

- 程序在运行时，如果 `Python 解释器` **遇到**
  到一个错误，**会停止程序的执行，并且提示一些错误信息**，这就是
  **异常**
- **程序停止执行并且提示错误信息**
  这个动作，我们通常称之为：**抛出(raise)异常**


> 程序开发时，很难将 **所有的特殊情况** 都处理的面面俱到，通过
> **异常捕获** 可以针对突发事件做集中的处理，从而保证程序的
> **稳定性和健壮性**

######  7.2.1  捕获异常 

 简单的捕获异常语法

- 在程序开发中，如果 **对某些代码的执行不能确定是否正确**，可以增加
  `try(尝试)` 来 **捕获异常**
- 捕获异常最简单的语法格式：

```python
try:
    尝试执行的代码
except:
    出现错误的处理
```

- `try` **尝试**，下方编写要尝试代码，不确定是否能够正常执行的代码
- `except` **如果不是**，下方编写尝试失败的代码

 简单异常捕获演练 ------ 要求用户输入整数 

```python
try:
    # 提示用户输入一个数字
    num = int(input("请输入数字："))
except:
    print("请输入正确的数字")
```

######  7.2.2 错误类型捕获 

- 在程序执行时，可能会遇到 **不同类型的异常**，并且需要
  **针对不同类型的异常，做出不同的响应**，这个时候，就需要捕获错误类型了
- 语法如下：

```python
try:
    # 尝试执行的代码
    pass
except 错误类型1:
    # 针对错误类型1，对应的代码处理
    pass
except (错误类型2, 错误类型3):
    # 针对错误类型2 和 3，对应的代码处理
    pass
except Exception as result:
    print("未知错误 %s" % result)
```

- 当 `Python` 解释器 **抛出异常**
  时，**最后一行错误信息的第一个单词，就是错误类型**

 异常类型捕获演练 ------ 要求用户输入整数

**需求**

1. 提示用户输入一个整数
2. 使用 `8` 除以用户输入的整数并且输出

```python
try:
    num = int(input("请输入整数："))
    result = 8 / num
    print(result)
except ValueError:
    print("请输入正确的整数")
except ZeroDivisionError:
    print("除 0 错误")
```

 捕获未知错误

- 在开发时，**要预判到所有可能出现的错误**，还是有一定难度的
- 如果希望程序 **无论出现任何错误**，都不会因为 `Python` 解释器
  **抛出异常而被终止**，可以再增加一个 `except`

语法如下：

```python
except Exception as result:
    print("未知错误 %s" % result)
```

###### 7.2.3 异常捕获完整语法 

- 在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下：

> 提示：
>
> - 有关完整语法的应用场景，在后续学习中，**结合实际的案例**会更好理解
> - 现在先对这个语法结构有个印象即可

```python
try:
    # 尝试执行的代码
    pass
except 错误类型1:
    # 针对错误类型1，对应的代码处理
    pass
except 错误类型2:
    # 针对错误类型2，对应的代码处理
    pass
except (错误类型3, 错误类型4):
    # 针对错误类型3 和 4，对应的代码处理
    pass
except Exception as result:
    # 打印错误信息
    print(result)
else:
    # 没有异常才会执行的代码
    pass
finally:
    # 无论是否有异常，都会执行的代码
    print("无论是否有异常，都会执行的代码")
```

- `else` 只有在没有异常时才会执行的代码
- `finally` 无论是否有异常，都会执行的代码
- 之前一个演练的 **完整捕获异常** 的代码如下：

```python
try:
    num = int(input("请输入整数："))
    result = 8 / num
    print(result)
except ValueError:
    print("请输入正确的整数")
except ZeroDivisionError:
    print("除 0 错误")
except Exception as result:
    print("未知错误 %s" % result)
else:
    print("正常执行")
finally:
    print("执行完成，但是不保证正确")
```

###### 7.2.3 异常的传递

- **异常的传递** ------ 当 **函数/方法** 执行 **出现异常**，会
  **将异常传递** 给 函数/方法 的 **调用一方**
- 如果 **传递到主程序**，仍然 **没有异常处理**，程序才会被终止

> 提示

- 在开发中，可以在主函数中增加 **异常捕获**
- 而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的
  **异常捕获** 中
- 这样就不需要在代码中，增加大量的 **异常捕获**，能够保证代码的整洁

**需求**

1. 定义函数 `demo1()` **提示用户输入一个整数并且返回**
2. 定义函数 `demo2()` 调用 `demo1()`
3. 在主程序中调用 `demo2()`

```python
def demo1():
    return int(input("请输入一个整数："))
```

```python
def demo2():
    return demo1()

try:
    print(demo2())
except ValueError:
    print("请输入正确的整数")
except Exception as result:
    print("未知错误 %s" % result)
```

######  7.2.4  抛出 `raise` 异常

- 在开发中，除了 **代码执行出错** `Python` 解释器会 **抛出** 异常之外
- 还可以根据 **应用程序** **特有的业务需求** **主动抛出异常**

**示例**

- 提示用户 **输入密码**，如果 **长度少于 8**，抛出 **异常**

**注意**

- 当前函数 **只负责** 提示用户输入密码，如果
  **密码长度不正确，需要其他的函数进行额外处理**
- 因此可以 **抛出异常**，由其他需要处理的函数 **捕获异常**

- `Python` 中提供了一个 `Exception` **异常类**
- 在开发时，如果满足 **特定业务需求时**，希望 **抛出异常**，可以：
  1. **创建** 一个 `Exception` 的 **对象**
  2. 使用 `raise` **关键字** 抛出 **异常对象**

**需求**

- 定义 `input_password` 函数，提示用户输入密码
- 如果用户输入长度 \< 8，抛出异常
- 如果用户输入长度 \>=8，返回输入的密码

```python
def input_password():

    # 1. 提示用户输入密码
    pwd = input("请输入密码：")

    # 2. 判断密码长度，如果长度 >= 8，返回用户输入的密码
    if len(pwd) >= 8:
        return pwd

    # 3. 密码长度不够，需要抛出异常
    # 1> 创建异常对象 - 使用异常的错误信息字符串作为参数
    ex = Exception("密码长度不够")

    # 2> 抛出异常对象
    raise ex
```

```python
try:
    user_pwd = input_password()
    print(user_pwd)
except Exception as result:
    print("发现错误：%s" % result)
```
##### 7.3  `eval` 函数 

`eval()` 函数十分强大 ------ **将字符串** 当成 **有效的表达式** 来求值
并 **返回计算结果**

```python
# 基本的数学计算
In [1]: eval("1 + 1")
Out[1]: 2

# 字符串重复
In [2]: eval("'*' * 10")
Out[2]: '**********'

# 将字符串转换成列表
In [3]: type(eval("[1, 2, 3, 4, 5]"))
Out[3]: list

# 将字符串转换成字典
In [4]: type(eval("{'name': 'xiaoming', 'age': 18}"))
Out[4]: dict
```

 案例 - 计算器 

**需求**

1. 提示用户输入一个 **加减乘除混合运算**
2. 返回计算结果

```python
input_str = input("请输入一个算术题：")

print(eval(input_str))
```

######  7.3.1 不要滥用 `eval`

> 在开发时千万不要使用 `eval` 直接转换 `input` 的结果

```python
__import__('os').system('ls')
```

- 等价代码

```python
import os

os.system("终端命令")
```

- 执行成功，返回 0
- 执行失败，返回错误信息

## 二 、面向对象实战-飞机大战

### 1、pygame模块

**游戏的第一印象**

- 把一些 **静止的图像** 绘制到 **游戏窗口** 中
- 根据 **用户的交互** 或其他情况，**移动** 这些图像，产生动画效果
- 根据 **图像之间** 是否发生重叠，判断 **敌机是否被摧毁** 等其他情况

#### 1.1  使用 `pygame` 创建图形窗口

1. 游戏的初始化和退出
2. 理解游戏中的坐标系
3. 创建游戏主窗口
4. 简单的游戏循环

> 可以将图片素材 **绘制** 到 **游戏的窗口** 上，开发游戏之前需要先知道 **如何建立游戏窗口**！

#####  1.1.1  游戏的初始化和退出

- 要使用 `pygame` 提供的所有功能之前，需要调用 `init` 方法
- 在游戏结束前需要调用一下 `quit` 方法 

| 方法            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| `pygame.init()` | 导入并初始化所有 `pygame` 模块，使用其他模块之前，必须先调用 `init` 方法 |
| `pygame.quit()` | 卸载所有 `pygame` 模块，在游戏结束之前调用！                 |


```python
import pygame

pygame.init()

# 游戏代码...

pygame.quit()

```

#####  1.1.2 理解游戏中的坐标系

- **坐标系**
  - **原点** 在 **左上角** `(0, 0)`
  - **x 轴** 水平方向向 **右**，逐渐增加
  - **y 轴** 垂直方向向 **下**，逐渐增加



- 在游戏中，**所有可见的元素** 都是以 **矩形区域** 来描述位置的
  - 要描述一个矩形区域有四个要素：`(x, y) (width, height)`
- `pygame` 专门提供了一个类 `pygame.Rect` 用于描述 **矩形区域**

```python
Rect(x, y, width, height) -> Rect
```

**提示**

- `pygame.Rect` 是一个比较特殊的类，内部只是封装了一些数字计算
- 不执行 `pygame.init()` 方法同样能够直接使用

##### 1.1.3  案例演练

**需求**

1. 定义 `hero_rect` 矩形描述 **英雄的位置和大小**
2. 输出英雄的 **坐标原点**（`x` 和 `y`）
3. 输出英雄的 **尺寸**（**宽度** 和 **高度**）

```python
hero_rect = pygame.Rect(100, 500, 120, 126)

print("坐标原点 %d %d" % (hero_rect.x, hero_rect.y))
print("英雄大小 %d %d" % (hero_rect.width, hero_rect.height))
# size 属性会返回矩形区域的 (宽, 高) 元组
print("英雄大小 %d %d" % hero_rect.size)
```

#### 1.2 创建游戏主窗口

- `pygame` 专门提供了一个 **模块** `pygame.display` 用于创建、管理 **游戏窗口**

| 方法                        | 说明                       |
| --------------------------- | -------------------------- |
| `pygame.display.set_mode()` | 初始化游戏显示窗口         |
| `pygame.display.update()`   | 刷新屏幕内容显示，稍后使用 |

**`set_mode` 方法**

```python
set_mode(resolution=(0,0), flags=0, depth=0) -> Surface
```

- **作用** —— 创建游戏显示窗口
- **参数**
  - `resolution` 指定屏幕的 `宽` 和 `高`，默认创建的窗口大小和屏幕大小一致
  - `flags` 参数指定屏幕的附加选项，例如是否全屏等等，默认不需要传递
  - `depth` 参数表示颜色的位数，默认自动匹配
- **返回值**
  - **暂时** 可以理解为 **游戏的屏幕**，**游戏的元素** 都需要被绘制到 **游戏的屏幕** 上
- **注意**：必须使用变量记录 `set_mode` 方法的返回结果！因为：后续所有的图像绘制都基于这个返回结果

```python
# 创建游戏主窗口
screen = pygame.display.set_mode((480, 700))
```

#### 1.3  简单的游戏循环

- 为了做到游戏程序启动后，**不会立即退出**，通常会在游戏程序中增加一个 **游戏循环**
- 所谓 **游戏循环** 就是一个 **无限循环**
- 在 **创建游戏窗口** 代码下方，增加一个无限循环
  - 注意：**游戏窗口不需要重复创建**

```python
# 创建游戏主窗口
screen = pygame.display.set_mode((480, 700))

# 游戏循环
while True:
    pass
```

### 2、  理解 **图像** 并实现图像绘制

- 在游戏中，能够看到的 **游戏元素** 大多都是 **图像**
  - **图像文件** 初始是保存在磁盘上的，如果需要使用，**第一步** 就需要 **被加载到内存**
- 要在屏幕上 **看到某一个图像的内容**，需要按照三个步骤：
  1. 使用 `pygame.image.load()` **加载图像的数据**
  2. 使用 **游戏屏幕** 对象，调用 `blit` 方法 将图像绘制到指定位置
  3. 调用 `pygame.display.update()` 方法更新整个屏幕的显示

![1561376246641](/1561376246641.png)

> 提示：要想在屏幕上看到绘制的结果，就一定要调用 `pygame.display.update()` 方法

#### 2.1  代码演练
##### 2.1.1 代码演练 I —— 绘制背景图像

**需求**

1. 加载 `background.png` 创建背景
2. 将 **背景** 绘制在屏幕的 `(0, 0)` 位置
3. 调用屏幕更新显示背景图像

```python
# 绘制背景图像
# 1> 加载图像
bg = pygame.image.load("./images/background.png")

# 2> 绘制在屏幕
screen.blit(bg, (0, 0))

# 3> 更新显示
pygame.display.update()
```

##### 2.1.2 代码演练 II —— 绘制英雄图像

**需求**

1. 加载 `me1.png` 创建英雄飞机
2. 将 **英雄飞机** 绘制在屏幕的 `(200, 500)` 位置
3. 调用屏幕更新显示飞机图像

```python
# 1> 加载图像
hero = pygame.image.load("./images/me1.png")

# 2> 绘制在屏幕
screen.blit(hero, (200, 500))

# 3> 更新显示
pygame.display.update()
```

**透明图像** 

- `png` 格式的图像是支持 **透明** 的
- 在绘制图像时，**透明区域** 不会显示任何内容
- 但是如果**下方已经有内容**，会 **透过** **透明区域** 显示出来

##### 2.2  理解 `update()` 方法的作用

> 可以在 `screen` 对象完成 **所有** `blit` 方法之后，**统一调用一次** `display.update` 方法，同样可以在屏幕上 **看到最终的绘制结果**

- 使用 `display.set_mode()` 创建的 `screen` **对象** 是一个 **内存中的屏幕数据对象**
  - 可以理解成是 **油画** 的 **画布**
- `screen.blit` 方法可以在 **画布** 上绘制很多 **图像**
  - 例如：**英雄**、**敌机**、**子弹**...
  - **这些图像** 有可能 会彼此 **重叠或者覆盖**
- `display.update()` 会将 **画布** 的 **最终结果** 绘制在屏幕上，这样可以 **提高屏幕绘制效率**，**增加游戏的流畅度**

**案例调整**

```python
# 绘制背景图像
# 1> 加载图像
bg = pygame.image.load("./images/background.png")

# 2> 绘制在屏幕
screen.blit(bg, (0, 0))

# 绘制英雄图像
# 1> 加载图像
hero = pygame.image.load("./images/me1.png")

# 2> 绘制在屏幕
screen.blit(hero, (200, 500))

# 3> 更新显示 - update 方法会把之前所有绘制的结果，一次性更新到屏幕窗口上
pygame.display.update()
```

#### 2.3  理解 **游戏循环** 和 **游戏时钟**

> 现在 **英雄飞机** 已经被绘制到屏幕上了，**怎么能够让飞机移动呢** ？

#####  2.3.1 游戏中的动画实现原理

- 跟 **电影** 的原理类似，游戏中的动画效果，本质上是 **快速** 的在屏幕上绘制 **图像**
  - 电影是将多张 **静止的电影胶片** **连续、快速**的播放，产生连贯的视觉效果！
- 一般在电脑上 **每秒绘制 60 次**，就能够达到非常 **连续** **高品质** 的动画效果
  - 每次绘制的结果被称为 **帧 Frame**


#####  2.3.2 **游戏循环**

- 游戏的两个组成部分

> **游戏循环的开始** 就意味着 **游戏的正式开始**

![1561376478714](/1561376478714.png)

- 游戏循环的作用

1. 保证游戏 **不会直接退出**
2. **变化图像位置** —— 动画效果
   - 每隔 `1 / 60 秒` 移动一下所有图像的位置
   - 调用 `pygame.display.update()` 更新屏幕显示
3. **检测用户交互** —— 按键、鼠标等...

### 3、  游戏时钟

- `pygame` 专门提供了一个类 `pygame.time.Clock` 可以非常方便的设置屏幕绘制速度 —— **刷新帧率**
- 要使用 **时钟对象** 需要两步：
  - 1）在 **游戏初始化** 创建一个 **时钟对象**
  - 2）在 **游戏循环** 中让时钟对象调用 `tick(帧率)` 方法 
- `tick` 方法会根据 **上次被调用的时间**，自动设置 **游戏循环** 中的延时

```python
# 3. 创建游戏时钟对象
clock = pygame.time.Clock()
i = 0

# 游戏循环
while True:

    # 设置屏幕刷新帧率
    clock.tick(60)

    print(i)
    i += 1
```

#### 3.1 英雄的简单动画实现

**需求**

1. 在 **游戏初始化** 定义一个 `pygame.Rect` 的变量记录英雄的初始位置
2. 在 **游戏循环** 中每次让 **英雄** 的 `y - 1` —— 向上移动 
3. `y <= 0` 将英雄移动到屏幕的底部

> 提示：
>
> - 每一次调用 `update()` 方法之前，需要把 **所有的游戏图像都重新绘制一遍**
> - 而且应该 **最先** 重新绘制 **背景图像**

```python
# 4. 定义英雄的初始位置
hero_rect = pygame.Rect(150, 500, 102, 126)

while True:

    # 可以指定循环体内部的代码执行的频率
    clock.tick(60)

    # 更新英雄位置
    hero_rect.y -= 1

    # 如果移出屏幕，则将英雄的顶部移动到屏幕底部
    if hero_rect.y <= 0:
        hero_rect.y = 700

    # 绘制背景图片
    screen.blit(bg, (0, 0))
    # 绘制英雄图像
    screen.blit(hero, hero_rect)

    # 更新显示
    pygame.display.update()
```


####  3.2 在游戏循环中 监听 事件 

##### 3.2.1  事件 `event`

- 就是游戏启动后，**用户针对游戏所做的操作**
- 例如：**点击关闭按钮**，**点击鼠标**，**按下键盘**...

##### 3.2.2  监听

- 在 **游戏循环** 中，判断用户 **具体的操作**

> 只有 **捕获** 到用户具体的操作，才能有针对性的做出响应

##### 3.2.3  代码实现

- `pygame` 中通过 `pygame.event.get()` 可以获得 **用户当前所做动作** 的 **事件列表**
  - 用户可以同一时间做很多事情
- 提示：**这段代码非常的固定**，几乎所有的 `pygame` 游戏都 **大同小异**！

```python
# 游戏循环
while True:

    # 设置屏幕刷新帧率
    clock.tick(60)

    # 事件监听
    for event in pygame.event.get():

        # 判断用户是否点击了关闭按钮
        if event.type == pygame.QUIT:
            print("退出游戏...")

            pygame.quit()

            # 直接退出系统
            exit()
```

### 4、 理解 **精灵** 和 **精灵组**

#### 4.1 精灵 和 精灵组

- 在刚刚完成的案例中，**图像加载**、**位置变化**、**绘制图像** 都需要程序员编写代码分别处理
- 为了简化开发步骤，`pygame` 提供了两个类
  - `pygame.sprite.Sprite` —— 存储 **图像数据 image** 和 **位置 rect** 的 **对象**
  - `pygame.sprite.Group`

![1561376710502](/1561376710502.png)

##### 4.1.1 精灵

- 在游戏开发中，通常把 **显示图像的对象** 叫做精灵 `Sprite`
- **精灵** 需要 有 **两个重要的属性**
  - `image` 要显示的图像
  - `rect` 图像要显示在屏幕的位置
- 默认的 `update()` 方法什么事情也没做
  - 子类可以重写此方法，在每次刷新屏幕时，更新精灵位置
- **注意**：`pygame.sprite.Sprite` 并没有提供 `image` 和 `rect` 两个属性
  - 需要程序员从 `pygame.sprite.Sprite` 派生子类
  - 并在 **子类** 的 **初始化方法** 中，设置 `image` 和 `rect` 属性

#####  4.1.2 精灵组

- 一个 **精灵组** 可以包含多个 **精灵** 对象
- 调用 **精灵组** 对象的 `update()` 方法
  - 可以 **自动** 调用 **组内每一个精灵** 的 `update()` 方法
- 调用 **精灵组** 对象的 `draw(屏幕对象)` 方法
  - 可以将 **组内每一个精灵** 的 `image` 绘制在 `rect` 位置

```python
Group(*sprites) -> Group
```

> 注意：仍然需要调用 `pygame.display.update()` 才能在屏幕看到最终结果

####  4.2 派生精灵子类

1. 新建 `plane_sprites.py` 文件
2. 定义 `GameSprite` 继承自 `pygame.sprite.Sprite`

**注意**

- 如果一个类的 **父类** 不是 `object`
- 在重写 **初始化方法** 时，**一定要** 先 `super()` 一下父类的 `__init__` 方法
- **保证父类中实现的 `__init__` 代码能够被正常执行**

![1561376781415](/1561376781415.png)

**属性**

- `image` 精灵图像，使用 `image_name` 加载
- `rect` 精灵大小，默认使用图像大小
- `speed` 精灵移动速度，默认为 `1`

**方法**

- `update` 每次更新屏幕时在游戏循环内调用
  - 让精灵的 `self.rect.y += self.speed`

**提示**

- `image` 的 `get_rect()` 方法，可以返回 **pygame.Rect(0, 0, 图像宽, 图像高)** 的对象

```python
import pygame


class GameSprite(pygame.sprite.Sprite):
    """游戏精灵基类"""
    
    def __init__(self, image_name, speed=1):
        
        # 调用父类的初始化方法
        super().__init__()
        
        # 加载图像
        self.image = pygame.image.load(image_name)
        # 设置尺寸
        self.rect = self.image.get_rect()
        # 记录速度
        self.speed = speed

    def update(self, *args):
        
        # 默认在垂直方向移动
        self.rect.y += self.speed
        
```

####  4.3 使用 游戏精灵 和 精灵组 创建敌机

**需求**

- 使用刚刚派生的 **游戏精灵** 和 **精灵组** 创建 敌机 并且实现敌机动画

**步骤**

1. 使用 `from` 导入 `plane_sprites` 模块 
   - `from` 导入的模块可以 **直接使用**
   - `import` 导入的模块需要通过 **模块名.** 来使用
2. 在 **游戏初始化** 创建 **精灵对象** 和 **精灵组对象**
3. 在 **游戏循环中** 让 **精灵组** 分别调用 `update()` 和 `draw(screen)` 方法

**职责**

- 精灵
  - 封装 **图像 image**、**位置 rect** 和 **速度 speed**
  - 提供 `update()` 方法，根据游戏需求，**更新位置 rect**
- 精灵组
  - 包含 **多个** **精灵对象**
  - `update` 方法，让精灵组中的所有精灵调用 `update` 方法更新位置
  - `draw(screen)` 方法，在 `screen` 上绘制精灵组中的所有精灵

#####  4.3.1 实现步骤

- 1) 导入 `plane_sprites` 模块

```python
from plane_sprites import *
```

- 2) 修改初始化部分代码

```python
# 创建敌机精灵和精灵组
enemy1 = GameSprite("./images/enemy1.png")
enemy2 = GameSprite("./images/enemy1.png", 2)
enemy2.rect.x = 200
enemy_group = pygame.sprite.Group(enemy1, enemy2)
```

- 3) 修改游戏循环部分代码

```python
# 让敌机组调用 update 和 draw 方法
enemy_group.update()
enemy_group.draw(screen)

# 更新屏幕显示
pygame.display.update()
```



### 5、  游戏框架搭建

**目标** —— 使用 **面相对象** 设计 **飞机大战游戏类**

- 明确主程序职责
- 实现主程序类
- 准备游戏精灵组

#### 5.1  明确主程序职责

- 回顾 **快速入门案例**，一个游戏主程序的 **职责** 可以分为两个部分：
  - 游戏初始化
  - 游戏循环
- 根据明确的职责，设计 `PlaneGame` 类如下：



![1561377210743](/1561377210743.png)



> **提示** 根据 **职责** 封装私有方法，可以避免某一个方法的代码写得太过冗长
>
> 如果某一个方法编写的太长，既不好阅读，也不好维护！

- **游戏初始化** ——  `__init__()` 会调用以下方法： 

| 方法                     | 职责                 |
| ------------------------ | -------------------- |
| `__create_sprites(self)` | 创建所有精灵和精灵组 |

- **游戏循环** —— `start_game()` 会调用以下方法：

| 方法                     | 职责                                   |
| ------------------------ | -------------------------------------- |
| `__event_handler(self)`  | 事件监听                               |
| `__check_collide(self)`  | 碰撞检测 —— 子弹销毁敌机、敌机撞毁英雄 |
| `__update_sprites(self)` | 精灵组更新和绘制                       |
| `__game_over()`          | 游戏结束                               |

#### 5.2 实现飞机大战主游戏类

##### 5.2.1 明确文件职责

- `plane_main` 
  1. 封装 **主游戏类**
  2. 创建 **游戏对象**
  3. **启动游戏**
- `plane_sprites`
  - 封装游戏中 **所有** 需要使用的 **精灵子类**
  - 提供游戏的 **相关工具**

##### 5.2.2  代码实现

- 新建 `plane_main.py` 文件
- 编写 **基础代码**

```python
import pygame
from plane_sprites import *


class PlaneGame(object):
    """飞机大战主游戏"""

    def __init__(self):
        print("游戏初始化")

    def start_game(self):
        print("开始游戏...")


if __name__ == '__main__':
    # 创建游戏对象
    game = PlaneGame()

    # 开始游戏
    game.start_game()

```

#####  5.2.3 游戏初始化部分

- 完成 `__init__()` 代码如下：

```python
def __init__(self):
    print("游戏初始化")
    
    # 1. 创建游戏的窗口
    self.screen = pygame.display.set_mode((480, 700))
    # 2. 创建游戏的时钟
    self.clock = pygame.time.Clock()
    # 3. 调用私有方法，精灵和精灵组的创建
    self.__create_sprites()

def __create_sprites(self):
    pass
```

-  使用 常量 代替固定的数值

> - 常量 —— 不变化的量
> - 变量 —— 可以变化的量

**应用场景**

- 在开发时，可能会需要使用 **固定的数值**，例如 **屏幕的高度** 是 `700`
- 这个时候，建议 **不要** 直接使用固定数值，而应该使用 **常量**
- 在开发时，为了保证代码的可维护性，尽量不要使用 **魔法数字** 

**常量的定义**

- 定义 **常量** 和 定义 **变量** 的语法完全一样，都是使用 **赋值语句**
- **常量** 的 **命名** 应该 **所有字母都使用大写**，**单词与单词之间使用下划线连接**

**常量的好处**

- 阅读代码时，通过 **常量名** **见名之意**，不需要猜测数字的含义
- 如果需要 **调整值**，只需要 **修改常量定义** 就可以实现 **统一修改**

> 提示：Python 中并没有真正意义的常量，只是通过命名的约定 —— 所有字母都是大写的就是常量，开发时不要轻易的修改！

**代码调整**

- 在 `plane_sprites.py` 中增加常量定义

```python
import pygame

# 游戏屏幕大小
SCREEN_RECT = pygame.Rect(0, 0, 480, 700)
```

- 修改 `plane_main.py` 中的窗口大小

```python
self.screen = pygame.display.set_mode(SCREEN_RECT.size)
```

##### 5.2.4 游戏循环部分

- 完成 `start_game()` 基础代码如下：

```python
def start_game(self):
    """开始游戏"""
    
    print("开始游戏...")
       
    while True:
    
        # 1. 设置刷新帧率
        self.clock.tick(60)
        
        # 2. 事件监听
        self.__event_handler()
        
        # 3. 碰撞检测
        self.__check_collide()
        
        # 4. 更新精灵组
        self.__update_sprites()
        
        # 5. 更新屏幕显示
        pygame.display.update()

def __event_handler(self):
    """事件监听"""
    
    for event in pygame.event.get():
    
        if event.type == pygame.QUIT:
            PlaneGame.__game_over()

def __check_collide(self):
    """碰撞检测"""
    pass

def __update_sprites(self):
    """更新精灵组"""
    pass
    
@staticmethod
def __game_over():
   """游戏结束"""

   print("游戏结束")
   pygame.quit()
   exit()
```

#### 5.3  准备游戏精灵组

#####  5.3.1 确定精灵组



![1561377386467](/1561377386467.png)


#####  5.3.2 代码实现

- 创建精灵组方法

```python
def __create_sprites(self):
    """创建精灵组"""
    
    # 背景组
    self.back_group = pygame.sprite.Group()
    # 敌机组
    self.enemy_group = pygame.sprite.Group()
    # 英雄组
    self.hero_group = pygame.sprite.Group()

```

- 更新精灵组方法

```python
def __update_sprites(self):
    """更新精灵组"""
    
    for group in [self.back_group, self.enemy_group, self.hero_group]:
    
        group.update()
        group.draw(self.screen)
```

### 6、 游戏背景

** 目标 **

- 背景交替滚动的思路确定
- 显示游戏背景

#### 6.1  背景交替滚动的思路确定

- 游戏启动后，**背景图像** 会 **连续不断地** **向下方** 移动
- 在 **视觉上** 产生英雄的飞机不断向上方飞行的 **错觉** —— 在很多跑酷类游戏中常用的套路
  - **游戏的背景** 不断变化
  - **游戏的主角** 位置保持不变

#####  6.1.1 实现思路分析

![1561377554338](/1561377554338.png)


**解决办法**

1. 创建两张背景图像精灵
   - 第 `1` 张 **完全和屏幕重合**
   - 第 `2` 张在 **屏幕的正上方**
2. 两张图像 **一起向下方运动**
   - `self.rect.y += self.speed`
3. 当 **任意背景精灵** 的 `rect.y >= 屏幕的高度` 说明已经 **移动到屏幕下方**
4. 将 **移动到屏幕下方的这张图像** 设置到 **屏幕的正上方**
   - `rect.y = -rect.height`  

##### 6.1.2 设计背景类

![1561377599720](/1561377599720.png)

- **初始化方法**
  - 直接指定 **背景图片**
  - `is_alt` 参数判断是否是另一张图像
    - `False` 表示 **第一张图像**，需要与屏幕重合
    - `True` 表示 **另一张图像**，在屏幕的正上方
- **update()** 方法
  - 判断 **是否移动出屏幕**，如果是，将图像设置到 **屏幕的正上方**，从而实现 **交替滚动**

> **继承** 如果父类提供的方法，不能满足子类的需求：
>
> - 派生一个子类
> - 在子类中针对特有的需求，重写父类方法，并且进行扩展

#### 6.2  显示游戏背景

##### 6.2.1 背景精灵的基本实现（继承、重写概念）

- 在 `plane_sprites` 新建 `Background` 继承自 `GameSprite`

```python
class Background(GameSprite):
    """游戏背景精灵"""

    def update(self):

        # 1. 调用父类的方法实现
        super().update()

        # 2. 判断是否移出屏幕，如果移出屏幕，将图像设置到屏幕的上方
        if self.rect.y >= SCREEN_RECT.height:
            self.rect.y = -self.rect.height

```

##### 6.2.2 在 `plane_main.py` 中显示背景精灵

1. 在 `__create_sprites` 方法中创建 **精灵** 和 **精灵组**
2. 在 `__update_sprites` 方法中，让 **精灵组** 调用 `update()` 和 `draw()` 方法

> `__create_sprites` 方法

```python
def __create_sprites(self):

    # 创建背景精灵和精灵组
    bg1 = Background("./images/background.png")
    bg2 = Background("./images/background.png")
    bg2.rect.y = -bg2.rect.height
    
    self.back_group = pygame.sprite.Group(bg1, bg2)
```

> `__update_sprites` 方法

```python
def __update_sprites(self):

    self.back_group.update()
    self.back_group.draw(self.screen)
```

#####  6.2.3 利用初始化方法，简化背景精灵创建

> 思考 —— 上一小结完成的代码存在什么样的问题？能否简化？

- 在主程序中，创建的**两个背景精灵**，**传入了相同的图像文件路径**
- 创建 **第二个 背景精灵** 时，**在主程序中**，设置背景精灵的图像位置

> 思考 —— 精灵 **初始位置** 的设置，应该 **由主程序负责**？还是 **由精灵自己负责**？

**答案** —— **由精灵自己负责**

- 根据面向对象设计原则，应该将对象的职责，封装到类的代码内部
- 尽量简化程序调用一方的代码调用

![1561377720536](/1561377720536.png)

- **初始化方法**
  - 直接指定 **背景图片**
  - `is_alt` 判断是否是另一张图像
    - `False` 表示 **第一张图像**，需要与屏幕重合
    - `True` 表示 **另一张图像**，在屏幕的正上方

在 `plane_sprites.py` 中实现 `Background` 的 **初始化方法**

```python
def __init__(self, is_alt=False):

    image_name = "./images/background.png"
    super().__init__(image_name)
       
    # 判断是否交替图片，如果是，将图片设置到屏幕顶部
    if is_alt:
        self.rect.y = -self.rect.height     
```

- 修改 `plane_main` 的 `__create_sprites` 方法

```python
# 创建背景精灵和精灵组
bg1 = Background()
bg2 = Background(True)

self.back_group = pygame.sprite.Group(bg1, bg2)
```

### 7、 敌机出场

- 目标

- 使用 **定时器** 添加敌机
- 设计 `Enemy` 类

#### 7.1  使用定时器添加敌机

1. 游戏启动后，**每隔 1 秒** 会 **出现一架敌机**
2. 每架敌机 **向屏幕下方飞行**，飞行 **速度各不相同**
3. 每架敌机出现的 **水平位置** 也不尽相同
4. 当敌机 **从屏幕下方飞出**，不会再飞回到屏幕中

##### 7.1.1 定时器

- 在 `pygame` 中可以使用 `pygame.time.set_timer()` 来添加 **定时器**
- 所谓 **定时器**，就是 **每隔一段时间**，去 **执行一些动作**

```python
set_timer(eventid, milliseconds) -> None
```

- `set_timer` 可以创建一个 **事件**
- 可以在 **游戏循环** 的 **事件监听** 方法中捕获到该事件
- 第 1 个参数 **事件代号** 需要基于常量 `pygame.USEREVENT` 来指定
  - `USEREVENT` 是一个整数，再增加的事件可以使用 `USEREVENT + 1` 指定，依次类推...
- 第 2 个参数是 **事件触发** 间隔的 **毫秒值**

**定时器事件的监听**

- 通过 `pygame.event.get()` 可以获取当前时刻所有的 **事件列表**
- **遍历列表** 并且判断 `event.type` 是否等于 `eventid`，如果相等，表示 **定时器事件** 发生

##### 7.1.2 定义并监听创建敌机的定时器事件

`pygame` 的 **定时器** 使用套路非常固定：

1. 定义 **定时器常量** —— `eventid`
2. 在 **初始化方法** 中，调用 `set_timer` 方法 **设置定时器事件**
3. 在 **游戏循环** 中，**监听定时器事件**

 1) 定义事件

- 在 `plane_sprites.py` 的顶部定义 **事件常量**

```python
# 敌机的定时器事件常量
CREATE_ENEMY_EVENT = pygame.USEREVENT
```

- 在 `PlaneGame` 的 **初始化方法** 中 **创建用户事件**

```python
# 4. 设置定时器事件 - 每秒创建一架敌机
pygame.time.set_timer(CREATE_ENEMY_EVENT, 1000)
```

 2) 监听定时器事件

- 在 `__event_handler` 方法中增加以下代码：

```python
def __event_handler(self):
    
    for event in pygame.event.get():
    
        # 判断是否退出游戏
        if event.type == pygame.QUIT:
            PlaneGame.__game_over()
        elif event.type == CREATE_ENEMY_EVENT:
            print("敌机出场...")
```

#### 7.2  设计 `Enemy` 类

1. 游戏启动后，**每隔 1 秒** 会 **出现一架敌机**
2. 每架敌机 **向屏幕下方飞行**，飞行 **速度各不相同**
3. 每架敌机出现的 **水平位置** 也不尽相同
4. 当敌机 **从屏幕下方飞出**，不会再飞回到屏幕中



![1561378016020](/1561378016020.png)



- **初始化方法**
  - 指定 **敌机图片**
  - **随机** 敌机的 **初始位置** 和 **初始速度**
- 重写 **update()** 方法
  - 判断 **是否飞出屏幕**，如果是，从 **精灵组** 删除

##### 7.2.1 敌机类的准备

- 在 `plane_sprites` 新建 `Enemy` 继承自 `GameSprite`
- 重写 **初始化方法**，直接指定 **图片名称**
- 暂时 **不实现** **随机速度** 和 **随机位置** 的指定
- 重写 `update` 方法，判断是否飞出屏幕

```python
class Enemy(GameSprite):
    """敌机精灵"""
    
    def __init__(self):
        
        # 1. 调用父类方法，创建敌机精灵，并且指定敌机的图像
        super().__init__("./images/enemy1.png")

        # 2. 设置敌机的随机初始速度

        # 3. 设置敌机的随机初始位置
    
    def update(self):
        
        # 1. 调用父类方法，让敌机在垂直方向运动
        super().update()
        
        # 2. 判断是否飞出屏幕，如果是，需要将敌机从精灵组删除
        if self.rect.y >= SCREEN_RECT.height:
            print("敌机飞出屏幕...")    
```

#####  7.2.2 创建敌机

**演练步骤**

1. 在 `__create_sprites`，添加 **敌机精灵组**
   - 敌机是 **定时被创建的**，因此在初始化方法中，不需要创建敌机
2. 在 `__event_handler`，创建敌机，并且 **添加到精灵组**
   - 调用 **精灵组** 的 `add` 方法可以 **向精灵组添加精灵**
3. 在 `__update_sprites`，让 **敌机精灵组** 调用 `update` 和 `draw` 方法

![1561378290331](/1561378290331.png)

**演练代码**

- 修改 `plane_main` 的 `__create_sprites` 方法

```python
# 敌机组
self.enemy_group = pygame.sprite.Group()
```

- 修改 `plane_main` 的 `__update_sprites` 方法

```python
self.enemy_group.update()
self.enemy_group.draw(self.screen)
```

- 定时出现敌机

```python
elif event.type == CREATE_ENEMY_EVENT:
    self.enemy_group.add(Enemy())
```

#####  7.2.3 随机敌机位置和速度

 1) 导入模块

- 在导入模块时，**建议** 按照以下顺序导入

```python
1. 官方标准模块导入
2. 第三方模块导入
3. 应用程序模块导入
```

- 修改 `plane_sprites.py` 增加 `random` 的导入

```python
import random
```

 2) 随机位置

使用 `pygame.Rect` 提供的 `bottom` 属性，在指定敌机初始位置时，会比较方便

- `bottom = y + height`
- `y = bottom - height`

 3) 代码实现

- 修改 **初始化方法**，随机敌机出现 **速度** 和 **位置**

```python
def __init__(self):

    # 1. 调用父类方法，创建敌机精灵，并且指定敌机的图像
    super().__init__("./images/enemy1.png")

    # 2. 设置敌机的随机初始速度 1 ~ 3
    self.speed = random.randint(1, 3)

    # 3. 设置敌机的随机初始位置
    self.rect.bottom = 0
    
    max_x = SCREEN_RECT.width - self.rect.width
    self.rect.x = random.randint(0, max_x)
```

#####  7.2.4 移出屏幕销毁敌机

- 敌机移出屏幕之后，如果 **没有撞到英雄**，敌机的历史使命已经终结
- 需要从 **敌机组** 删除，否则会造成 **内存浪费**

- 检测敌机被销毁

- `__del__` 内置方法会在对象被销毁前调用，在开发中，可以用于 **判断对象是否被销毁**

```python
def __del__(self):
    print("敌机挂了 %s" % self.rect)
```

- 代码实现

- 判断敌机是否飞出屏幕，如果是，调用 `kill()` 方法从所有组中删除

```python
def update(self):
    super().update()
    
    # 判断敌机是否移出屏幕
    if self.rect.y >= SCREEN_RECT.height:
        # 将精灵从所有组中删除
        self.kill()
```

### 8、  英雄登场

- 设计 **英雄** 和 **子弹** 类
- 使用 `pygame.key.get_pressed()` 移动英雄
- 发射子弹

#### 8.1 设计 **英雄** 和 **子弹** 类

- 英雄需求

1. 游戏启动后，**英雄** 出现在屏幕的 **水平中间** 位置，距离 **屏幕底部** `120` **像素**
2. **英雄** 每隔 `0.5` 秒发射一次子弹，每次 **连发三枚子弹**
3. **英雄** 默认不会移动，需要通过 **左/右** 方向键，控制 **英雄** 在水平方向移动

![1561378443164](/1561378443164.png)

- 子弹需求

1. **子弹** 从 **英雄** 的正上方发射 **沿直线** 向 **上方** 飞行
2. **飞出屏幕后**，需要从 **精灵组** 中删除

![1561378489747](/1561378489747.png)

- Hero —— 英雄

- **初始化方法**
  - 指定 **英雄图片**
  - **初始速度 = 0** —— 英雄默认静止不动
  - 定义 `bullets` **子弹精灵组** 保存子弹精灵
- 重写 **update()** 方法
  - 英雄需要 **水平移动**
  - 并且需要保证不能 **移出屏幕**
- 增加 `bullets` 属性，记录所有 **子弹精灵**
- 增加 `fire` 方法，用于发射子弹

- Bullet —— 子弹

- **初始化方法**
  - 指定 **子弹图片**
  - **初始速度 = -2** —— 子弹需要向上方飞行
- 重写 **update()** 方法
  - 判断 **是否飞出屏幕**，如果是，从 **精灵组** 删除

#### 8.2 创建英雄

##### 8.2.1 准备英雄类

- 在 `plane_sprites` 新建 `Hero` 类
- 重写 **初始化方法**，直接指定 **图片名称**，并且将初始速度设置为 `0`
- 设置 **英雄的初始位置**

![1561378552266](/1561378552266.png)

- `centerx = x + 0.5 * width`
- `centery = y + 0.5 * height`
- `bottom = y + height`

![1561378569719](/1561378569719.png)

```python
class Hero(GameSprite):
    """英雄精灵"""

    def __init__(self):

        super().__init__("./images/me1.png", 0)

        # 设置初始位置
        self.rect.centerx = SCREEN_RECT.centerx
        self.rect.bottom = SCREEN_RECT.bottom - 120
```

#####  8.2.2 绘制英雄

1. 在 `__create_sprites`，添加 **英雄精灵** 和 **英雄精灵组**
   - 后续要针对 **英雄** 做 **碰撞检测** 以及 **发射子弹**
   - 所以 **英雄** 需要 **单独定义成属性**
2. 在 `__update_sprites`，让 **英雄精灵组** 调用 `update` 和 `draw` 方法

- 代码实现

- 修改 `__create_sprites` 方法如下：

```python
# 英雄组
self.hero = Hero()
self.hero_group = pygame.sprite.Group(self.hero)
```

- 修改 `__update_sprites` 方法如下：

```python
self.hero_group.update()
self.hero_group.draw(self.screen)
```

#### 8.3 移动英雄位置

> 在 `pygame` 中针对 **键盘按键的捕获**，有 **两种** 方式

- **第一种方式** 判断 `event.type == pygame.KEYDOWN`
- **第二种方式** 
  1. 首先使用 `pygame.key.get_pressed()` 返回 **所有按键元组**
  2. 通过 **键盘常量**，判断元组中 **某一个键是否被按下** —— 如果被按下，对应数值为 `1`

**提问** 这两种方式之间有什么区别呢？

- 第一种方式

```python
elif event.type == pygame.KEYDOWN and event.key == pygame.K_RIGHT:
    print("向右移动...")
```

- 第二种方式

```python
# 返回所有按键的元组，如果某个键被按下，对应的值会是1
keys_pressed = pygame.key.get_pressed()
# 判断是否按下了方向键
if keys_pressed[pygame.K_RIGHT]:
    print("向右移动...")
```

**结论**

- **第一种方式** `event.type` 用户 **必须要抬起按键** 才算一次 **按键事件**，**操作灵活性会大打折扣**
- **第二种方式** 用户可以按住方向键不放，就能够实现持续向某一个方向移动了，**操作灵活性更好**


**演练步骤**

1. 在 `Hero` 类中重写 `update` 方法
   - 用 **速度** `speed` 和 **英雄** `rect.x` 进行叠加
   - **不需要调用父类方法** —— 父类方法只是实现了单纯的垂直运动
2. 在 `__event_handler` 方法中根据 **左右方向键** 设置英雄的 **速度**
   - **向右** => `speed = 2`
   - **向左** => `speed = -2`
   - **其他** => `speed = 0`

**代码演练**

- 在 `Hero` 类，重写 `update()` 方法，**根据速度水平移动** 英雄的飞机

```python
def update(self):

    # 飞机水平移动
    self.rect.x += self.speed
```

- 调整键盘按键代码

```python
# 获取用户按键
keys_pressed = pygame.key.get_pressed()

if keys_pressed[pygame.K_RIGHT]:
    self.hero.speed = 2
elif keys_pressed[pygame.K_LEFT]:
    self.hero.speed = -2
else:
    self.hero.speed = 0
```

#####8. 3.1  控制英雄运动边界

- 在 `Hero` 类的 `update()` 方法判断 **英雄** 是否超出 **屏幕边界**


- `right = x + width` 利用 `right` 属性可以非常容易的针对右侧设置精灵位置

![1561378692492](/1561378692492.png)

```python
def update(self):

    # 飞机水平移动
    self.rect.x += self.speed
    
    # 判断屏幕边界
    if self.rect.left < 0:
        self.rect.left = 0
    if self.rect.right > SCREEN_RECT.right:
        self.rect.right = SCREEN_RECT.right
```

####  8.4  发射子弹

 需求回顾 —— 英雄需求

1. 游戏启动后，**英雄** 出现在屏幕的 **水平中间** 位置，距离 **屏幕底部** `120` **像素**
2. **英雄** 每隔 `0.5` 秒发射一次子弹，每次 **连发三枚子弹**
3. **英雄** 默认不会移动，需要通过 **左/右** 方向键，控制 **英雄** 在水平方向移动

##### 8.4.1 添加发射子弹事件

`pygame` 的 **定时器** 使用套路非常固定：

1. 定义 **定时器常量** —— `eventid`
2. 在 **初始化方法** 中，调用 `set_timer` 方法 **设置定时器事件**
3. 在 **游戏循环** 中，**监听定时器事件**

**代码实现**

- 在 `Hero` 中定义 `fire` 方法

```python
def fire(self):
    print("发射子弹...")
```

- 在 `plane_main.py` 的顶部定义 **发射子弹** 事件常量

```python
# 英雄发射子弹事件
HERO_FIRE_EVENT = pygame.USEREVENT + 1
```

- 在 `__init__` 方法末尾中添加 **发射子弹** 事件

```python
# 每隔 0.5 秒发射一次子弹
pygame.time.set_timer(HERO_FIRE_EVENT, 500)
```

- 在 `__event_handler` 方法中让英雄发射子弹

```python
elif event.type == HERO_FIRE_EVENT:
    self.hero.fire()
```

#####  8.4.2 定义子弹类

 需求回顾 —— 子弹需求

1. **子弹** 从 **英雄** 的正上方发射 **沿直线** 向 **上方** 飞行
2. **飞出屏幕后**，需要从 **精灵组** 中删除

- Bullet —— 子弹

- **初始化方法**
  - 指定 **子弹图片**
  - **初始速度 = -2** —— 子弹需要向上方飞行
- 重写 **update()** 方法
  - 判断 **是否飞出屏幕**，如果是，从 **精灵组** 删除

- 定义子弹类

- 在 `plane_sprites` 新建 `Bullet` 继承自 `GameSprite`
- 重写 **初始化方法**，直接指定 **图片名称**，并且设置 **初始速度**
- 重写 `update()` 方法，判断子弹 **飞出屏幕从精灵组删除**

```python
class Bullet(GameSprite):
    """子弹精灵"""
    
    def __init__(self):
        
        super().__init__("./images/bullet1.png", -2)
 
    def update(self):
    
        super().update()
        
        # 判断是否超出屏幕，如果是，从精灵组删除
        if self.rect.bottom < 0:
            self.kill()
```

##### 8.4.3 发射子弹

**演练步骤**

1. 在 `Hero` 的 **初始化方法** 中创建 **子弹精灵组** 属性
2. 修改 `plane_main.py` 的 `__update_sprites` 方法，让 **子弹精灵组** 调用 `update` 和 `draw` 方法
3. 实现 `fire()` 方法
   - 创建子弹精灵
   - 设置初始位置 —— 在 **英雄的正上方**
   - 将 **子弹** 添加到精灵组

**代码实现**

- 初始化方法

```python
# 创建子弹的精灵组
self.bullets = pygame.sprite.Group()
```

- 修改 `fire()` 方法

```python
def fire(self):

    # 1. 创建子弹精灵
    bullet = Bullet()
    
    # 2. 设置精灵的位置
    bullet.rect.bottom = self.rect.y - 20
    bullet.rect.centerx = self.rect.centerx
    
    # 3. 将精灵添加到精灵组
    self.bullets.add(bullet)
```

-  一次发射三枚子弹

- 修改 `fire()` 方法，一次发射三枚子弹

```python
def fire(self):

    for i in (1, 2, 3):
        # 1. 创建子弹精灵
        bullet = Bullet()
        
        # 2. 设置精灵的位置
        bullet.rect.bottom = self.rect.y - i * 20
        bullet.rect.centerx = self.rect.centerx
        
        # 3. 将精灵添加到精灵组
        self.bullets.add(bullet)
```

### 9、 碰撞检测

目标

- 了解碰撞检测方法
- 碰撞实现

#### 9.1 了解碰撞检测方法

- `pygame` 提供了 **两个非常方便** 的方法可以实现碰撞检测：

1. pygame.sprite.groupcollide()

- **两个精灵组** 中 **所有的精灵** 的碰撞检测

```python
groupcollide(group1, group2, dokill1, dokill2, collided = None) -> Sprite_dict
```

- 如果将 `dokill` 设置为 `True`，则 **发生碰撞的精灵将被自动移除**
- `collided` 参数是用于 **计算碰撞的回调函数**
  - 如果没有指定，则每个精灵必须有一个 `rect` 属性

2. pygame.sprite.spritecollide()

- 判断 **某个精灵** 和 **指定精灵组** 中的精灵的碰撞

```python
spritecollide(sprite, group, dokill, collided = None) -> Sprite_list
```

- 如果将 `dokill` 设置为 `True`，则 **指定精灵组** 中 **发生碰撞的精灵将被自动移除**
- `collided` 参数是用于 **计算碰撞的回调函数**
  - 如果没有指定，则每个精灵必须有一个 `rect` 属性
- 返回 **精灵组** 中跟 **精灵** 发生碰撞的 **精灵列表**

####  9.2  碰撞实现

```python
def __check_collide(self):

    # 1. 子弹摧毁敌机
    pygame.sprite.groupcollide(self.hero.bullets, self.enemy_group, True, True)
    
    # 2. 敌机撞毁英雄
    enemies = pygame.sprite.spritecollide(self.hero, self.enemy_group, True)
    
    # 判断列表时候有内容
    if len(enemies) > 0:
    
        # 让英雄牺牲
        self.hero.kill()
        
        # 结束游戏
        PlaneGame.__game_over()
```


